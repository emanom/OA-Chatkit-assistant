{"version":3,"sources":["../src/types/thread.ts","../src/types/attachments.ts","../src/types/sources.ts","../src/types/workflow.ts","../src/types/items.ts","../src/types/requests.ts","../src/types/events.ts","../src/types/store.ts","../src/errors/index.ts","../src/utils/logger.ts","../src/server/results.ts","../src/server/ChatKitServer.ts","../src/agents/widget-helpers.ts","../src/utils/id.ts","../src/server/widget-stream.ts","../src/store/Store.ts","../src/store/AttachmentStore.ts","../src/agents/index.ts","../src/agents/types.ts","../src/agents/context-helpers.ts","../src/agents/input-item-converter.ts","../src/agents/input-converter.ts","../src/agents/merge-streams.ts","../src/agents/stream-converter.ts","../src/agents/item-converter.ts"],"names":["ErrorCode","before","after","generateId","widgetItem","NotFoundError","thread","key","workflowItem"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Thread types - conversations and their metadata\n */\n\nimport type { Page } from './base.js';\nimport type { ThreadItem } from './items.js';\n\n/**\n * Status indicating the thread is active.\n */\nexport interface ActiveStatus {\n  type: 'active';\n}\n\n/**\n * Status indicating the thread is locked.\n */\nexport interface LockedStatus {\n  type: 'locked';\n  reason?: string | null;\n}\n\n/**\n * Status indicating the thread is closed.\n */\nexport interface ClosedStatus {\n  type: 'closed';\n  reason?: string | null;\n}\n\n/**\n * Union of lifecycle states for a thread.\n */\nexport type ThreadStatus = ActiveStatus | LockedStatus | ClosedStatus;\n\n/**\n * Metadata describing a thread without its items.\n */\nexport interface ThreadMetadata {\n  id: string;\n  title?: string | null;\n  created_at: string; // ISO 8601 datetime string\n  status: ThreadStatus;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Thread with its paginated items.\n */\nexport interface Thread extends ThreadMetadata {\n  items: Page<ThreadItem>;\n}\n\n/**\n * Type guard to check if status is active.\n */\nexport function isActiveStatus(status: ThreadStatus): status is ActiveStatus {\n  return status.type === 'active';\n}\n\n/**\n * Type guard to check if status is locked.\n */\nexport function isLockedStatus(status: ThreadStatus): status is LockedStatus {\n  return status.type === 'locked';\n}\n\n/**\n * Type guard to check if status is closed.\n */\nexport function isClosedStatus(status: ThreadStatus): status is ClosedStatus {\n  return status.type === 'closed';\n}\n","/**\n * Attachment types - files and images attached to messages\n */\n\n/**\n * Base metadata shared by all attachments.\n */\nexport interface AttachmentBase {\n  id: string;\n  name: string;\n  mime_type: string;\n  /**\n   * The URL to upload the file, used for two-phase upload.\n   * Should be set to null after upload is complete or when using direct upload\n   * where uploading happens when creating the attachment object.\n   */\n  upload_url?: string | null;\n}\n\n/**\n * Attachment representing a generic file.\n */\nexport interface FileAttachment extends AttachmentBase {\n  type: 'file';\n}\n\n/**\n * Attachment representing an image resource.\n */\nexport interface ImageAttachment extends AttachmentBase {\n  type: 'image';\n  preview_url: string;\n}\n\n/**\n * Union of supported attachment types.\n */\nexport type Attachment = FileAttachment | ImageAttachment;\n\n/**\n * Metadata needed to initialize an attachment.\n */\nexport interface AttachmentCreateParams {\n  name: string;\n  size: number;\n  mime_type: string;\n}\n\n/**\n * Type guard for FileAttachment.\n */\nexport function isFileAttachment(attachment: Attachment): attachment is FileAttachment {\n  return attachment.type === 'file';\n}\n\n/**\n * Type guard for ImageAttachment.\n */\nexport function isImageAttachment(attachment: Attachment): attachment is ImageAttachment {\n  return attachment.type === 'image';\n}\n","/**\n * Source types - references to files, URLs, and entities\n */\n\n/**\n * Base class for sources displayed to users.\n */\nexport interface SourceBase {\n  title: string;\n  description?: string | null;\n  timestamp?: string | null;\n  group?: string | null;\n}\n\n/**\n * Source metadata for file-based references.\n */\nexport interface FileSource extends SourceBase {\n  type: 'file';\n  filename: string;\n}\n\n/**\n * Source metadata for external URLs.\n */\nexport interface URLSource extends SourceBase {\n  type: 'url';\n  url: string;\n  attribution?: string | null;\n}\n\n/**\n * Source metadata for entity references.\n */\nexport interface EntitySource extends SourceBase {\n  type: 'entity';\n  id: string;\n  icon?: string | null;\n  preview?: 'lazy' | null;\n}\n\n/**\n * Union of supported source types.\n */\nexport type Source = URLSource | FileSource | EntitySource;\n\n/**\n * Type guard for URLSource.\n */\nexport function isURLSource(source: Source): source is URLSource {\n  return source.type === 'url';\n}\n\n/**\n * Type guard for FileSource.\n */\nexport function isFileSource(source: Source): source is FileSource {\n  return source.type === 'file';\n}\n\n/**\n * Type guard for EntitySource.\n */\nexport function isEntitySource(source: Source): source is EntitySource {\n  return source.type === 'entity';\n}\n","/**\n * Workflow and task types\n */\n\nimport type { FileSource, URLSource } from './sources.js';\n\n/**\n * Base fields common to all workflow tasks.\n */\nexport interface BaseTask {\n  /**\n   * Only used when rendering the task as part of a workflow.\n   * Indicates the status of the task.\n   */\n  status_indicator?: 'none' | 'loading' | 'complete';\n}\n\n/**\n * Workflow task displaying custom content.\n */\nexport interface CustomTask extends BaseTask {\n  type: 'custom';\n  title?: string | null;\n  icon?: string | null;\n  content?: string | null;\n}\n\n/**\n * Workflow task representing a web search.\n */\nexport interface SearchTask extends BaseTask {\n  type: 'web_search';\n  title?: string | null;\n  title_query?: string | null;\n  queries: string[];\n  sources: URLSource[];\n}\n\n/**\n * Workflow task capturing assistant reasoning.\n */\nexport interface ThoughtTask extends BaseTask {\n  type: 'thought';\n  title?: string | null;\n  content: string;\n}\n\n/**\n * Workflow task referencing file sources.\n */\nexport interface FileTask extends BaseTask {\n  type: 'file';\n  title?: string | null;\n  sources: FileSource[];\n}\n\n/**\n * Workflow task rendering image content.\n */\nexport interface ImageTask extends BaseTask {\n  type: 'image';\n  title?: string | null;\n}\n\n/**\n * Union of workflow task variants.\n */\nexport type Task = CustomTask | SearchTask | ThoughtTask | FileTask | ImageTask;\n\n/**\n * Custom summary for a workflow.\n */\nexport interface CustomSummary {\n  title: string;\n  icon?: string | null;\n}\n\n/**\n * Summary providing total workflow duration.\n */\nexport interface DurationSummary {\n  /**\n   * The duration of the workflow in seconds\n   */\n  duration: number;\n}\n\n/**\n * Summary variants available for workflows.\n */\nexport type WorkflowSummary = CustomSummary | DurationSummary;\n\n/**\n * Workflow attached to a thread with optional summary.\n */\nexport interface Workflow {\n  type: 'custom' | 'reasoning';\n  tasks: Task[];\n  summary?: WorkflowSummary | null;\n  expanded: boolean;\n}\n\n/**\n * Type guard for CustomTask.\n */\nexport function isCustomTask(task: Task): task is CustomTask {\n  return task.type === 'custom';\n}\n\n/**\n * Type guard for SearchTask.\n */\nexport function isSearchTask(task: Task): task is SearchTask {\n  return task.type === 'web_search';\n}\n\n/**\n * Type guard for ThoughtTask.\n */\nexport function isThoughtTask(task: Task): task is ThoughtTask {\n  return task.type === 'thought';\n}\n\n/**\n * Type guard for FileTask.\n */\nexport function isFileTask(task: Task): task is FileTask {\n  return task.type === 'file';\n}\n\n/**\n * Type guard for ImageTask.\n */\nexport function isImageTask(task: Task): task is ImageTask {\n  return task.type === 'image';\n}\n","/**\n * Thread item types - messages, widgets, tasks, etc.\n */\n\nimport type { InferenceOptions } from './base.js';\nimport type { Attachment } from './attachments.js';\nimport type { Source } from './sources.js';\nimport type { WidgetRoot } from './widgets.js';\nimport type { Task, Workflow } from './workflow.js';\n\n/**\n * Base fields shared by all thread items.\n */\nexport interface ThreadItemBase {\n  id: string;\n  thread_id: string;\n  created_at: string; // ISO 8601 datetime string\n}\n\n/**\n * User message content containing plaintext.\n */\nexport interface UserMessageTextContent {\n  type: 'input_text';\n  text: string;\n}\n\n/**\n * User message content representing an interactive tag.\n */\nexport interface UserMessageTagContent {\n  type: 'input_tag';\n  id: string;\n  text: string;\n  data: Record<string, unknown>;\n  interactive: boolean;\n}\n\n/**\n * Union of allowed user message content payloads.\n */\nexport type UserMessageContent = UserMessageTextContent | UserMessageTagContent;\n\n/**\n * Payload describing a user message submission.\n */\nexport interface UserMessageInput {\n  content: UserMessageContent[];\n  attachments: string[];\n  quoted_text?: string | null;\n  inference_options: InferenceOptions;\n}\n\n/**\n * Thread item representing a user message.\n */\nexport interface UserMessageItem extends ThreadItemBase {\n  type: 'user_message';\n  content: UserMessageContent[];\n  attachments: Attachment[];\n  quoted_text?: string | null;\n  inference_options: InferenceOptions;\n}\n\n/**\n * Reference to supporting context attached to assistant output.\n */\nexport interface Annotation {\n  type: 'annotation';\n  source: Source;\n  index?: number | null;\n}\n\n/**\n * Assistant message content consisting of text and annotations.\n */\nexport interface AssistantMessageContent {\n  type: 'output_text';\n  text: string;\n  annotations: Annotation[];\n}\n\n/**\n * Thread item representing an assistant message.\n */\nexport interface AssistantMessageItem extends ThreadItemBase {\n  type: 'assistant_message';\n  content: AssistantMessageContent[];\n}\n\n/**\n * Thread item capturing a client tool call.\n */\nexport interface ClientToolCallItem extends ThreadItemBase {\n  type: 'client_tool_call';\n  status: 'pending' | 'completed';\n  call_id: string;\n  name: string;\n  arguments: Record<string, unknown>;\n  output?: unknown;\n}\n\n/**\n * Thread item containing widget content.\n */\nexport interface WidgetItem extends ThreadItemBase {\n  type: 'widget';\n  widget: WidgetRoot;\n  copy_text?: string | null;\n}\n\n/**\n * Thread item containing a task.\n */\nexport interface TaskItem extends ThreadItemBase {\n  type: 'task';\n  task: Task;\n}\n\n/**\n * Thread item representing a workflow.\n */\nexport interface WorkflowItem extends ThreadItemBase {\n  type: 'workflow';\n  workflow: Workflow;\n}\n\n/**\n * Marker item indicating the assistant ends its turn.\n */\nexport interface EndOfTurnItem extends ThreadItemBase {\n  type: 'end_of_turn';\n}\n\n/**\n * HiddenContext is never sent to the client. It's not officially part of ChatKit.\n * It is only used internally to store additional context in a specific place in the thread.\n */\nexport interface HiddenContextItem extends ThreadItemBase {\n  type: 'hidden_context_item';\n  content: unknown;\n}\n\n/**\n * Union of all thread item variants.\n */\nexport type ThreadItem =\n  | UserMessageItem\n  | AssistantMessageItem\n  | ClientToolCallItem\n  | WidgetItem\n  | WorkflowItem\n  | TaskItem\n  | HiddenContextItem\n  | EndOfTurnItem;\n\n/**\n * Type guard for UserMessageItem.\n */\nexport function isUserMessage(item: ThreadItem): item is UserMessageItem {\n  return item.type === 'user_message';\n}\n\n/**\n * Type guard for AssistantMessageItem.\n */\nexport function isAssistantMessage(item: ThreadItem): item is AssistantMessageItem {\n  return item.type === 'assistant_message';\n}\n\n/**\n * Type guard for ClientToolCallItem.\n */\nexport function isClientToolCall(item: ThreadItem): item is ClientToolCallItem {\n  return item.type === 'client_tool_call';\n}\n\n/**\n * Type guard for WidgetItem.\n */\nexport function isWidgetItem(item: ThreadItem): item is WidgetItem {\n  return item.type === 'widget';\n}\n\n/**\n * Type guard for TaskItem.\n */\nexport function isTaskItem(item: ThreadItem): item is TaskItem {\n  return item.type === 'task';\n}\n\n/**\n * Type guard for WorkflowItem.\n */\nexport function isWorkflowItem(item: ThreadItem): item is WorkflowItem {\n  return item.type === 'workflow';\n}\n\n/**\n * Type guard for EndOfTurnItem.\n */\nexport function isEndOfTurn(item: ThreadItem): item is EndOfTurnItem {\n  return item.type === 'end_of_turn';\n}\n\n/**\n * Type guard for HiddenContextItem.\n */\nexport function isHiddenContext(item: ThreadItem): item is HiddenContextItem {\n  return item.type === 'hidden_context_item';\n}\n","/**\n * Request types - all ChatKit API request payloads\n */\n\nimport type { ActionConfig } from './actions.js';\nimport type { AttachmentCreateParams } from './attachments.js';\nimport type { FeedbackKind } from './base.js';\nimport type { UserMessageInput } from './items.js';\nimport type { ThreadStatus } from './thread.js';\n\n/**\n * Base class for all request payloads.\n */\nexport interface BaseReq {\n  /**\n   * Arbitrary integration-specific metadata.\n   */\n  metadata?: Record<string, unknown>;\n}\n\n// ========== STREAMING REQUESTS ==========\n\n/**\n * User input required to create a thread.\n */\nexport interface ThreadCreateParams {\n  input: UserMessageInput;\n}\n\n/**\n * Request to create a new thread from a user message.\n */\nexport interface ThreadsCreateReq extends BaseReq {\n  type: 'threads.create';\n  params: ThreadCreateParams;\n}\n\n/**\n * Parameters for adding a user message to a thread.\n */\nexport interface ThreadAddUserMessageParams {\n  thread_id: string;\n  input: UserMessageInput;\n}\n\n/**\n * Request to append a user message to a thread.\n */\nexport interface ThreadsAddUserMessageReq extends BaseReq {\n  type: 'threads.add_user_message';\n  params: ThreadAddUserMessageParams;\n}\n\n/**\n * Parameters for recording tool output in a thread.\n */\nexport interface ThreadAddClientToolOutputParams {\n  thread_id: string;\n  result: unknown;\n}\n\n/**\n * Request to add a client tool's output to a thread.\n */\nexport interface ThreadsAddClientToolOutputReq extends BaseReq {\n  type: 'threads.add_client_tool_output';\n  params: ThreadAddClientToolOutputParams;\n}\n\n/**\n * Parameters specifying which item to retry.\n */\nexport interface ThreadRetryAfterItemParams {\n  thread_id: string;\n  item_id: string;\n}\n\n/**\n * Request to retry processing after a specific thread item.\n */\nexport interface ThreadsRetryAfterItemReq extends BaseReq {\n  type: 'threads.retry_after_item';\n  params: ThreadRetryAfterItemParams;\n}\n\n/**\n * Parameters describing the custom action to execute.\n */\nexport interface ThreadCustomActionParams {\n  thread_id: string;\n  item_id?: string | null;\n  action: ActionConfig;\n}\n\n/**\n * Request to execute a custom action within a thread.\n */\nexport interface ThreadsCustomActionReq extends BaseReq {\n  type: 'threads.custom_action';\n  params: ThreadCustomActionParams;\n}\n\n/**\n * Union of request types that produce streaming responses.\n */\nexport type StreamingReq =\n  | ThreadsCreateReq\n  | ThreadsAddUserMessageReq\n  | ThreadsAddClientToolOutputReq\n  | ThreadsRetryAfterItemReq\n  | ThreadsCustomActionReq;\n\n// ========== NON-STREAMING REQUESTS ==========\n\n/**\n * Parameters for retrieving a thread by id.\n */\nexport interface ThreadGetByIdParams {\n  thread_id: string;\n}\n\n/**\n * Request to fetch a single thread by its identifier.\n */\nexport interface ThreadsGetByIdReq extends BaseReq {\n  type: 'threads.get_by_id';\n  params: ThreadGetByIdParams;\n}\n\n/**\n * Pagination parameters for listing threads.\n */\nexport interface ThreadListParams {\n  limit?: number | null;\n  order?: 'asc' | 'desc';\n  after?: string | null;\n}\n\n/**\n * Request to list threads.\n */\nexport interface ThreadsListReq extends BaseReq {\n  type: 'threads.list';\n  params: ThreadListParams;\n}\n\n/**\n * Parameters for updating a thread's properties.\n */\nexport interface ThreadUpdateParams {\n  thread_id: string;\n  title: string;\n  status?: ThreadStatus;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Request to update thread metadata.\n */\nexport interface ThreadsUpdateReq extends BaseReq {\n  type: 'threads.update';\n  params: ThreadUpdateParams;\n}\n\n/**\n * Parameters identifying a thread to delete.\n */\nexport interface ThreadDeleteParams {\n  thread_id: string;\n}\n\n/**\n * Request to delete a thread.\n */\nexport interface ThreadsDeleteReq extends BaseReq {\n  type: 'threads.delete';\n  params: ThreadDeleteParams;\n}\n\n/**\n * Pagination parameters for listing thread items.\n */\nexport interface ItemsListParams {\n  thread_id: string;\n  limit?: number | null;\n  order?: 'asc' | 'desc';\n  after?: string | null;\n}\n\n/**\n * Request to list items inside a thread.\n */\nexport interface ItemsListReq extends BaseReq {\n  type: 'items.list';\n  params: ItemsListParams;\n}\n\n/**\n * Parameters describing feedback targets and sentiment.\n */\nexport interface ItemFeedbackParams {\n  thread_id: string;\n  item_ids: string[];\n  kind: FeedbackKind;\n}\n\n/**\n * Request to submit feedback on specific items.\n */\nexport interface ItemsFeedbackReq extends BaseReq {\n  type: 'items.feedback';\n  params: ItemFeedbackParams;\n}\n\n/**\n * Request to register a new attachment.\n */\nexport interface AttachmentsCreateReq extends BaseReq {\n  type: 'attachments.create';\n  params: AttachmentCreateParams;\n}\n\n/**\n * Parameters identifying an attachment to delete.\n */\nexport interface AttachmentDeleteParams {\n  attachment_id: string;\n}\n\n/**\n * Request to remove an attachment.\n */\nexport interface AttachmentsDeleteReq extends BaseReq {\n  type: 'attachments.delete';\n  params: AttachmentDeleteParams;\n}\n\n/**\n * Union of request types that yield immediate responses.\n */\nexport type NonStreamingReq =\n  | ThreadsGetByIdReq\n  | ThreadsListReq\n  | ThreadsUpdateReq\n  | ThreadsDeleteReq\n  | ItemsListReq\n  | ItemsFeedbackReq\n  | AttachmentsCreateReq\n  | AttachmentsDeleteReq;\n\n/**\n * Union of all ChatKit request types.\n */\nexport type ChatKitReq = StreamingReq | NonStreamingReq;\n\n/**\n * Type guard to check if the given request should be processed as streaming.\n */\nexport function isStreamingReq(request: ChatKitReq): request is StreamingReq {\n  return [\n    'threads.create',\n    'threads.add_user_message',\n    'threads.add_client_tool_output',\n    'threads.retry_after_item',\n    'threads.custom_action',\n  ].includes(request.type);\n}\n\n/**\n * Type guard to check if the given request should be processed as non-streaming.\n */\nexport function isNonStreamingReq(request: ChatKitReq): request is NonStreamingReq {\n  return !isStreamingReq(request);\n}\n","/**\n * Event types - streaming events emitted to clients\n */\n\nimport type { IconName } from './base.js';\nimport type { Annotation, AssistantMessageContent, ThreadItem } from './items.js';\nimport type { Thread } from './thread.js';\nimport type { Task } from './workflow.js';\nimport type { WidgetComponent, WidgetRoot } from './widgets.js';\n\n// ========== THREAD STREAM EVENTS ==========\n\n/**\n * Event emitted when a thread is created.\n */\nexport interface ThreadCreatedEvent {\n  type: 'thread.created';\n  thread: Thread;\n}\n\n/**\n * Event emitted when a thread is updated.\n */\nexport interface ThreadUpdatedEvent {\n  type: 'thread.updated';\n  thread: Thread;\n}\n\n/**\n * Event emitted when a new item is added to a thread.\n */\nexport interface ThreadItemAddedEvent {\n  type: 'thread.item.added';\n  item: ThreadItem;\n}\n\n/**\n * Event emitted when a thread item is marked complete.\n */\nexport interface ThreadItemDoneEvent {\n  type: 'thread.item.done';\n  item: ThreadItem;\n}\n\n/**\n * Event emitted when a thread item is replaced.\n */\nexport interface ThreadItemReplacedEvent {\n  type: 'thread.item.replaced';\n  item: ThreadItem;\n}\n\n/**\n * Event emitted when a thread item is removed.\n */\nexport interface ThreadItemRemovedEvent {\n  type: 'thread.item.removed';\n  item_id: string;\n}\n\n// ========== THREAD ITEM UPDATE EVENTS ==========\n\n/**\n * Event describing an update to an existing thread item.\n */\nexport interface ThreadItemUpdated {\n  type: 'thread.item.updated';\n  item_id: string;\n  update: ThreadItemUpdate;\n}\n\n/**\n * Event emitted when new assistant content is appended.\n */\nexport interface AssistantMessageContentPartAdded {\n  type: 'assistant_message.content_part.added';\n  content_index: number;\n  content: AssistantMessageContent;\n}\n\n/**\n * Event carrying incremental assistant text output.\n */\nexport interface AssistantMessageContentPartTextDelta {\n  type: 'assistant_message.content_part.text_delta';\n  content_index: number;\n  delta: string;\n}\n\n/**\n * Event announcing a new annotation on assistant content.\n */\nexport interface AssistantMessageContentPartAnnotationAdded {\n  type: 'assistant_message.content_part.annotation_added';\n  content_index: number;\n  annotation_index: number;\n  annotation: Annotation;\n}\n\n/**\n * Event indicating an assistant content part is finalized.\n */\nexport interface AssistantMessageContentPartDone {\n  type: 'assistant_message.content_part.done';\n  content_index: number;\n  content: AssistantMessageContent;\n}\n\n/**\n * Event streaming widget text deltas.\n */\nexport interface WidgetStreamingTextValueDelta {\n  type: 'widget.streaming_text.value_delta';\n  component_id: string;\n  delta: string;\n  done: boolean;\n}\n\n/**\n * Event published when the widget root changes.\n */\nexport interface WidgetRootUpdated {\n  type: 'widget.root.updated';\n  widget: WidgetRoot;\n}\n\n/**\n * Event emitted when a widget component updates.\n */\nexport interface WidgetComponentUpdated {\n  type: 'widget.component.updated';\n  component_id: string;\n  component: WidgetComponent;\n}\n\n/**\n * Event emitted when a workflow task is added.\n */\nexport interface WorkflowTaskAdded {\n  type: 'workflow.task.added';\n  task_index: number;\n  task: Task;\n}\n\n/**\n * Event emitted when a workflow task is updated.\n */\nexport interface WorkflowTaskUpdated {\n  type: 'workflow.task.updated';\n  task_index: number;\n  task: Task;\n}\n\n/**\n * Union of possible updates applied to thread items.\n */\nexport type ThreadItemUpdate =\n  | AssistantMessageContentPartAdded\n  | AssistantMessageContentPartTextDelta\n  | AssistantMessageContentPartAnnotationAdded\n  | AssistantMessageContentPartDone\n  | WidgetStreamingTextValueDelta\n  | WidgetComponentUpdated\n  | WidgetRootUpdated\n  | WorkflowTaskAdded\n  | WorkflowTaskUpdated;\n\n// ========== STATUS EVENTS ==========\n\n/**\n * Event providing incremental progress from the assistant.\n */\nexport interface ProgressUpdateEvent {\n  type: 'progress_update';\n  text: string;\n  icon?: IconName | null;\n}\n\n/**\n * Event indicating an error occurred while processing a thread.\n */\nexport interface ErrorEvent {\n  type: 'error';\n  code?: string;\n  message?: string | null;\n  allow_retry: boolean;\n}\n\n/**\n * Event conveying a user-facing notice.\n */\nexport interface NoticeEvent {\n  type: 'notice';\n  level: 'info' | 'warning' | 'danger';\n  /**\n   * Supports markdown e.g. \"You've reached your limit of 100 messages. [Upgrade](https://...) to a paid plan.\"\n   */\n  message: string;\n  title?: string | null;\n}\n\n/**\n * Union of all streaming events emitted to clients.\n */\nexport type ThreadStreamEvent =\n  | ThreadCreatedEvent\n  | ThreadUpdatedEvent\n  | ThreadItemDoneEvent\n  | ThreadItemAddedEvent\n  | ThreadItemUpdated\n  | ThreadItemRemovedEvent\n  | ThreadItemReplacedEvent\n  | ProgressUpdateEvent\n  | ErrorEvent\n  | NoticeEvent;\n\n// ========== TYPE GUARDS ==========\n\n/**\n * Type guard for ThreadCreatedEvent.\n */\nexport function isThreadCreatedEvent(event: ThreadStreamEvent): event is ThreadCreatedEvent {\n  return event.type === 'thread.created';\n}\n\n/**\n * Type guard for ThreadUpdatedEvent.\n */\nexport function isThreadUpdatedEvent(event: ThreadStreamEvent): event is ThreadUpdatedEvent {\n  return event.type === 'thread.updated';\n}\n\n/**\n * Type guard for ThreadItemAddedEvent.\n */\nexport function isThreadItemAddedEvent(event: ThreadStreamEvent): event is ThreadItemAddedEvent {\n  return event.type === 'thread.item.added';\n}\n\n/**\n * Type guard for ThreadItemDoneEvent.\n */\nexport function isThreadItemDoneEvent(event: ThreadStreamEvent): event is ThreadItemDoneEvent {\n  return event.type === 'thread.item.done';\n}\n\n/**\n * Type guard for ThreadItemReplacedEvent.\n */\nexport function isThreadItemReplacedEvent(\n  event: ThreadStreamEvent\n): event is ThreadItemReplacedEvent {\n  return event.type === 'thread.item.replaced';\n}\n\n/**\n * Type guard for ThreadItemRemovedEvent.\n */\nexport function isThreadItemRemovedEvent(\n  event: ThreadStreamEvent\n): event is ThreadItemRemovedEvent {\n  return event.type === 'thread.item.removed';\n}\n\n/**\n * Type guard for ErrorEvent.\n */\nexport function isErrorEvent(event: ThreadStreamEvent): event is ErrorEvent {\n  return event.type === 'error';\n}\n\n/**\n * Type guard for ProgressUpdateEvent.\n */\nexport function isProgressUpdateEvent(event: ThreadStreamEvent): event is ProgressUpdateEvent {\n  return event.type === 'progress_update';\n}\n\n/**\n * Type guard for NoticeEvent.\n */\nexport function isNoticeEvent(event: ThreadStreamEvent): event is NoticeEvent {\n  return event.type === 'notice';\n}\n","/**\n * Store types - data persistence interfaces\n */\n\n/**\n * Type of store item for ID generation.\n */\nexport type StoreItemType = 'message' | 'tool_call' | 'task' | 'workflow' | 'attachment';\n\n/**\n * Error thrown when a requested resource is not found in the store.\n */\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NotFoundError';\n    Object.setPrototypeOf(this, NotFoundError.prototype);\n  }\n}\n","/**\n * Error classes for ChatKit SDK\n */\n\n/**\n * Error codes that can be emitted in error events.\n */\nexport enum ErrorCode {\n  STREAM_ERROR = 'stream.error',\n  INTERNAL_ERROR = 'internal.error',\n  INVALID_REQUEST = 'invalid.request',\n  THREAD_NOT_FOUND = 'thread.not_found',\n  ITEM_NOT_FOUND = 'item.not_found',\n  ATTACHMENT_NOT_FOUND = 'attachment.not_found',\n  THREAD_LOCKED = 'thread.locked',\n  THREAD_CLOSED = 'thread.closed',\n}\n\n/**\n * Error thrown during stream processing that should be conveyed to the client.\n */\nexport class StreamError extends Error {\n  code: string | ErrorCode;\n  allowRetry: boolean;\n\n  constructor(code: string | ErrorCode, allowRetry: boolean = false) {\n    super(`Stream error: ${code}`);\n    this.name = 'StreamError';\n    this.code = code;\n    this.allowRetry = allowRetry;\n    Object.setPrototypeOf(this, StreamError.prototype);\n  }\n}\n\n/**\n * Custom error with a user-facing message that should be displayed to the client.\n */\nexport class CustomStreamError extends Error {\n  allowRetry: boolean;\n\n  constructor(message: string, allowRetry: boolean = false) {\n    super(message);\n    this.name = 'CustomStreamError';\n    this.allowRetry = allowRetry;\n    Object.setPrototypeOf(this, CustomStreamError.prototype);\n  }\n}\n","/**\n * Simple logging interface\n */\n\nexport interface Logger {\n  info(message: string, extra?: Record<string, unknown>): void;\n  warn(message: string, extra?: Record<string, unknown>): void;\n  error(message: string, extra?: Record<string, unknown>): void;\n  debug(message: string, extra?: Record<string, unknown>): void;\n}\n\n/**\n * Default console logger implementation\n */\nclass ConsoleLogger implements Logger {\n  info(message: string, extra?: Record<string, unknown>): void {\n    if (extra) {\n      console.log(`[INFO] ${message}`, extra);\n    } else {\n      console.log(`[INFO] ${message}`);\n    }\n  }\n\n  warn(message: string, extra?: Record<string, unknown>): void {\n    if (extra) {\n      console.warn(`[WARN] ${message}`, extra);\n    } else {\n      console.warn(`[WARN] ${message}`);\n    }\n  }\n\n  error(message: string, extra?: Record<string, unknown>): void {\n    if (extra) {\n      console.error(`[ERROR] ${message}`, extra);\n    } else {\n      console.error(`[ERROR] ${message}`);\n    }\n  }\n\n  debug(message: string, extra?: Record<string, unknown>): void {\n    if (extra) {\n      console.debug(`[DEBUG] ${message}`, extra);\n    } else {\n      console.debug(`[DEBUG] ${message}`);\n    }\n  }\n}\n\n/**\n * Default logger instance\n */\nexport const defaultLogger: Logger = new ConsoleLogger();\n","/**\n * Result classes for streaming and non-streaming responses\n */\n\nimport type { ThreadStreamEvent } from '../types/events.js';\n\n/**\n * Streaming result that formats events as Server-Sent Events (SSE).\n * Format: `data: {json}\\n\\n` for each event.\n */\nexport class StreamingResult {\n  readonly isStreaming = true;\n  private generator: AsyncGenerator<ThreadStreamEvent>;\n\n  constructor(generator: AsyncGenerator<ThreadStreamEvent>) {\n    this.generator = generator;\n  }\n\n  /**\n   * Async iterator that yields SSE-formatted strings.\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<string> {\n    for await (const event of this.generator) {\n      // Serialize the event, excluding null values\n      const json = JSON.stringify(event, (_, value) => (value === null ? undefined : value));\n      // Format as SSE\n      yield `data: ${json}\\n\\n`;\n    }\n  }\n}\n\n/**\n * Non-streaming result that returns a JSON response.\n */\nexport class NonStreamingResult {\n  readonly isStreaming = false;\n  private data: unknown;\n\n  constructor(data: unknown) {\n    this.data = data;\n  }\n\n  /**\n   * Get the response data as a JSON-serializable object.\n   */\n  toJSON(): unknown {\n    return this.data;\n  }\n\n  /**\n   * Get the response data as a JSON string.\n   */\n  toString(): string {\n    return JSON.stringify(this.data, (_, value) => (value === null ? undefined : value));\n  }\n}\n","/**\n * ChatKitServer - Abstract base class for implementing ChatKit backend servers\n *\n * Users extend this class and implement the abstract `respond()` method to handle\n * incoming messages. The server handles request routing, event streaming, error\n * handling, and storage integration.\n */\n\nimport type { Store } from '../store/Store.js';\nimport type { AttachmentStore } from '../store/AttachmentStore.js';\nimport type { Logger } from '../utils/logger.js';\nimport { defaultLogger } from '../utils/logger.js';\nimport { StreamingResult, NonStreamingResult } from './results.js';\nimport { StreamError, CustomStreamError, ErrorCode } from '../errors/index.js';\nimport type {\n  ChatKitReq,\n  StreamingReq,\n  NonStreamingReq,\n  ThreadsCreateReq,\n  ThreadsAddUserMessageReq,\n  ThreadsAddClientToolOutputReq,\n  ThreadsRetryAfterItemReq,\n  ThreadsCustomActionReq,\n  ThreadsGetByIdReq,\n  ThreadsListReq,\n  ThreadsUpdateReq,\n  ThreadsDeleteReq,\n  ItemsListReq,\n  ItemsFeedbackReq,\n  AttachmentsCreateReq,\n  AttachmentsDeleteReq,\n} from '../types/requests.js';\nimport { isStreamingReq } from '../types/requests.js';\nimport type {\n  ThreadStreamEvent,\n  ThreadCreatedEvent,\n  ThreadItemDoneEvent,\n  ThreadItemReplacedEvent,\n  ThreadItemRemovedEvent,\n  ErrorEvent,\n  ThreadUpdatedEvent,\n} from '../types/events.js';\nimport type {\n  ThreadMetadata,\n  Thread,\n  UserMessageItem,\n  FeedbackKind,\n  Action,\n  WidgetItem,\n  Page,\n  // HiddenContextItem - unused, just checking type string instead\n} from '../types/index.js';\n\nconst DEFAULT_PAGE_SIZE = 20;\n\n/**\n * Abstract ChatKitServer class\n *\n * @example\n * ```typescript\n * class MyServer extends ChatKitServer<{ userId: string }> {\n *   async *respond(thread, inputUserMessage, context) {\n *     // Your implementation here\n *     yield {\n *       type: 'thread.item.done',\n *       item: {\n *         type: 'assistant_message',\n *         // ... message details\n *       }\n *     };\n *   }\n * }\n * ```\n */\nexport abstract class ChatKitServer<TContext = unknown> {\n  protected store: Store<TContext>;\n  protected attachmentStore?: AttachmentStore<TContext>;\n  protected logger: Logger;\n\n  constructor(\n    store: Store<TContext>,\n    attachmentStore?: AttachmentStore<TContext>,\n    logger?: Logger\n  ) {\n    this.store = store;\n    this.attachmentStore = attachmentStore;\n    this.logger = logger || defaultLogger;\n  }\n\n  /**\n   * Get the configured attachment store or throw if not configured\n   */\n  protected getAttachmentStore(): AttachmentStore<TContext> {\n    if (!this.attachmentStore) {\n      throw new Error(\n        'AttachmentStore is not configured. Provide an AttachmentStore to ChatKitServer to handle file operations.'\n      );\n    }\n    return this.attachmentStore;\n  }\n\n  /**\n   * Abstract method: Stream ThreadStreamEvent instances for a new user message\n   *\n   * This is the primary method users must implement to handle incoming messages\n   * and generate responses.\n   *\n   * @param thread - Metadata for the thread being processed\n   * @param inputUserMessage - The incoming message to respond to, or null for retry/tool output\n   * @param context - Per-request context provided by the caller\n   * @returns AsyncGenerator yielding ThreadStreamEvent instances\n   */\n  abstract respond(\n    thread: ThreadMetadata,\n    inputUserMessage: UserMessageItem | null,\n    context: TContext\n  ): AsyncGenerator<ThreadStreamEvent>;\n\n  /**\n   * Optional: Handle feedback on thread items\n   *\n   * Override this method to store or process user feedback (thumbs up/down).\n   * Default implementation does nothing.\n   *\n   * @param threadId - Thread ID\n   * @param itemIds - List of item IDs receiving feedback\n   * @param feedback - 'positive' or 'negative'\n   * @param context - Request context\n   */\n  async addFeedback(\n    threadId: string,\n    itemIds: string[],\n    feedback: FeedbackKind,\n    _context: TContext\n  ): Promise<void> {\n    // Default: do nothing\n    this.logger.debug('Feedback received', { threadId, itemIds, feedback });\n  }\n\n  /**\n   * Optional: Handle custom actions from widgets\n   *\n   * Override this method to react to button clicks and form submissions from widgets.\n   * Default implementation throws NotImplementedError.\n   *\n   * @param thread - Thread metadata\n   * @param action - Action payload from widget\n   * @param sender - Widget item that sent the action, if any\n   * @param context - Request context\n   * @returns AsyncGenerator yielding ThreadStreamEvent instances\n   */\n  async *action(\n    _thread: ThreadMetadata,\n    _action: Action,\n    _sender: WidgetItem | null,\n    _context: TContext\n  ): AsyncGenerator<ThreadStreamEvent> {\n    throw new Error(\n      'The action() method must be overridden to react to actions. ' +\n        'See ChatKit documentation for widget actions.'\n    );\n  }\n\n  /**\n   * Main entry point: Process a ChatKit request\n   *\n   * Parses the request JSON, routes to appropriate handler, and returns\n   * either a StreamingResult or NonStreamingResult.\n   *\n   * @param request - JSON request string or buffer\n   * @param context - Per-request context\n   * @returns StreamingResult or NonStreamingResult\n   */\n  async process(\n    request: string | Buffer,\n    context: TContext\n  ): Promise<StreamingResult | NonStreamingResult> {\n    // Parse request\n    const requestStr = typeof request === 'string' ? request : request.toString('utf-8');\n    const parsedRequest: ChatKitReq = JSON.parse(requestStr) as ChatKitReq;\n\n    this.logger.info(`Received request op: ${parsedRequest.type}`);\n\n    // Route to streaming or non-streaming handler\n    if (isStreamingReq(parsedRequest)) {\n      return new StreamingResult(this.processStreaming(parsedRequest, context));\n    } else {\n      const result = await this.processNonStreaming(parsedRequest, context);\n      return new NonStreamingResult(result);\n    }\n  }\n\n  /**\n   * Process non-streaming requests (returns JSON)\n   */\n  protected async processNonStreaming(\n    request: NonStreamingReq,\n    context: TContext\n  ): Promise<unknown> {\n    switch (request.type) {\n      case 'threads.get_by_id': {\n        const req = request as ThreadsGetByIdReq;\n        const thread = await this.loadFullThread(req.params.thread_id, context);\n        return this.toThreadResponse(thread);\n      }\n\n      case 'threads.list': {\n        const req = request as ThreadsListReq;\n        const params = req.params;\n        const threads = await this.store.loadThreads(\n          params.limit || DEFAULT_PAGE_SIZE,\n          params.after || null,\n          params.order || 'desc',\n          context\n        );\n        return {\n          has_more: threads.has_more,\n          after: threads.after,\n          data: threads.data.map((thread) => this.toThreadResponse(thread)),\n        };\n      }\n\n      case 'threads.update': {\n        const req = request as ThreadsUpdateReq;\n        const thread = await this.store.loadThread(req.params.thread_id, context);\n        if (req.params.title !== undefined) {\n          thread.title = req.params.title;\n        }\n        await this.store.saveThread(thread, context);\n        return this.toThreadResponse(thread);\n      }\n\n      case 'threads.delete': {\n        const req = request as ThreadsDeleteReq;\n        await this.store.deleteThread(req.params.thread_id, context);\n        return {};\n      }\n\n      case 'items.list': {\n        const req = request as ItemsListReq;\n        const params = req.params;\n        const items = await this.store.loadThreadItems(\n          params.thread_id,\n          params.after || null,\n          params.limit || DEFAULT_PAGE_SIZE,\n          params.order || 'asc',\n          context\n        );\n        // Filter out HiddenContextItems\n        items.data = items.data.filter((item) => item.type !== 'hidden_context_item');\n        return items;\n      }\n\n      case 'items.feedback': {\n        const req = request as ItemsFeedbackReq;\n        await this.addFeedback(\n          req.params.thread_id,\n          req.params.item_ids,\n          req.params.kind,\n          context\n        );\n        return {};\n      }\n\n      case 'attachments.create': {\n        const req = request as AttachmentsCreateReq;\n        const attachmentStore = this.getAttachmentStore();\n        const attachment = await attachmentStore.createAttachment(req.params, context);\n        await this.store.saveAttachment(attachment, context);\n        return attachment;\n      }\n\n      case 'attachments.delete': {\n        const req = request as AttachmentsDeleteReq;\n        const attachmentStore = this.getAttachmentStore();\n        await attachmentStore.deleteAttachment(req.params.attachment_id, context);\n        await this.store.deleteAttachment(req.params.attachment_id, context);\n        return {};\n      }\n\n      default: {\n        const exhaustiveCheck: never = request;\n        throw new Error(`Unknown request type: ${(exhaustiveCheck as any).type}`);\n      }\n    }\n  }\n\n  /**\n   * Process streaming requests (returns SSE stream)\n   */\n  protected async *processStreaming(\n    request: StreamingReq,\n    context: TContext\n  ): AsyncGenerator<ThreadStreamEvent> {\n    try {\n      yield* this.processStreamingImpl(request, context);\n    } catch (error) {\n      this.logger.error('Error while generating streamed response', { error });\n      throw error;\n    }\n  }\n\n  /**\n   * Implementation of streaming request processing\n   */\n  protected async *processStreamingImpl(\n    request: StreamingReq,\n    context: TContext\n  ): AsyncGenerator<ThreadStreamEvent> {\n    switch (request.type) {\n      case 'threads.create': {\n        const req = request as ThreadsCreateReq;\n        console.log('DEBUG threads.create params:', JSON.stringify(req.params, null, 2));\n        // Create thread\n        const thread: ThreadMetadata = {\n          id: this.store.generateThreadId(context),\n          title: null,\n          created_at: new Date().toISOString(),\n          status: { type: 'active' },\n          metadata: {},\n        };\n        await this.store.saveThread(thread, context);\n\n        // Emit thread.created\n        yield {\n          type: 'thread.created',\n          thread: this.toThreadResponse(thread),\n        } as ThreadCreatedEvent;\n\n        // Build user message\n        const userMessage = await this.buildUserMessageItem(req.params.input, thread, context);\n\n        // Process and respond\n        yield* this.processNewThreadItemRespond(thread, userMessage, context);\n        break;\n      }\n\n      case 'threads.add_user_message': {\n        const req = request as ThreadsAddUserMessageReq;\n        const thread = await this.store.loadThread(req.params.thread_id, context);\n        const userMessage = await this.buildUserMessageItem(req.params.input, thread, context);\n        yield* this.processNewThreadItemRespond(thread, userMessage, context);\n        break;\n      }\n\n      case 'threads.add_client_tool_output': {\n        const req = request as ThreadsAddClientToolOutputReq;\n        const thread = await this.store.loadThread(req.params.thread_id, context);\n\n        // Find the most recent pending client_tool_call item\n        const items = await this.store.loadThreadItems(\n          req.params.thread_id,\n          null,\n          1000, // Load enough items to find the pending tool call\n          'desc', // Most recent first\n          context\n        );\n\n        const pendingToolCall = items.data.find(\n          (item) => item.type === 'client_tool_call' && item.status === 'pending'\n        );\n\n        if (!pendingToolCall) {\n          throw new Error('No pending client tool call found');\n        }\n\n        // Update the tool call with the result\n        const updatedToolCall = {\n          ...pendingToolCall,\n          status: 'completed' as const,\n          output: req.params.result,\n        };\n\n        await this.store.saveItem(thread.id, updatedToolCall, context);\n\n        // Emit thread.item.replaced event\n        yield {\n          type: 'thread.item.replaced',\n          item: updatedToolCall,\n        } as ThreadItemReplacedEvent;\n\n        // Call respond() with null message to continue processing\n        yield* this.processEvents(thread, context, () => this.respond(thread, null, context));\n        break;\n      }\n\n      case 'threads.retry_after_item': {\n        const req = request as ThreadsRetryAfterItemReq;\n        const thread = await this.store.loadThread(req.params.thread_id, context);\n\n        // Load all items up to find the context\n        const items = await this.store.loadThreadItems(\n          req.params.thread_id,\n          null,\n          1000, // Load enough items\n          'asc', // Chronological order\n          context\n        );\n\n        // Find the index of the specified item\n        const itemIndex = items.data.findIndex((item) => item.id === req.params.item_id);\n        if (itemIndex === -1) {\n          throw new Error(`Item ${req.params.item_id} not found in thread`);\n        }\n\n        // Find the last user message before or at this item\n        let lastUserMessage: UserMessageItem | null = null;\n        for (let i = itemIndex; i >= 0; i--) {\n          const item = items.data[i];\n          if (item && item.type === 'user_message') {\n            lastUserMessage = item as UserMessageItem;\n            break;\n          }\n        }\n\n        if (!lastUserMessage) {\n          throw new Error('No user message found before the specified item');\n        }\n\n        // Call respond() to retry from this user message\n        yield* this.processEvents(thread, context, () =>\n          this.respond(thread, lastUserMessage, context)\n        );\n        break;\n      }\n\n      case 'threads.custom_action': {\n        const req = request as ThreadsCustomActionReq;\n        const thread = await this.store.loadThread(req.params.thread_id, context);\n\n        // Load the sender widget if item_id is provided\n        let senderWidget: WidgetItem | null = null;\n        if (req.params.item_id) {\n          const item = await this.store.loadItem(\n            thread.id,\n            req.params.item_id,\n            context\n          );\n          if (item.type === 'widget') {\n            senderWidget = item as WidgetItem;\n          }\n        }\n\n        // Call user's action() method and process events\n        yield* this.processEvents(thread, context, () =>\n          this.action(thread, req.params.action, senderWidget, context)\n        );\n        break;\n      }\n\n      default: {\n        const exhaustiveCheck: never = request;\n        throw new Error(`Unknown request type: ${(exhaustiveCheck as any).type}`);\n      }\n    }\n  }\n\n  /**\n   * Process a new user message and generate response\n   */\n  protected async *processNewThreadItemRespond(\n    thread: ThreadMetadata,\n    item: UserMessageItem,\n    context: TContext\n  ): AsyncGenerator<ThreadStreamEvent> {\n    // Save user message\n    await this.store.addThreadItem(thread.id, item, context);\n\n    // Emit thread.item.done for user message\n    yield {\n      type: 'thread.item.done',\n      item,\n    } as ThreadItemDoneEvent;\n\n    // Call user's respond() method and process events\n    yield* this.processEvents(thread, context, () => this.respond(thread, item, context));\n  }\n\n  /**\n   * Process events from user's respond() method\n   *\n   * Handles:\n   * - Saving items to store\n   * - Error handling\n   * - Thread updates\n   * - Filtering hidden context items\n   */\n  protected async *processEvents(\n    thread: ThreadMetadata,\n    context: TContext,\n    streamFn: () => AsyncGenerator<ThreadStreamEvent>\n  ): AsyncGenerator<ThreadStreamEvent> {\n    let lastThread: ThreadMetadata = { ...thread };\n\n    try {\n      for await (const event of streamFn()) {\n        // Save items to store based on event type\n        switch (event.type) {\n          case 'thread.item.done': {\n            const doneEvent = event as ThreadItemDoneEvent;\n            await this.store.addThreadItem(thread.id, doneEvent.item, context);\n            break;\n          }\n          case 'thread.item.removed': {\n            const removedEvent = event as ThreadItemRemovedEvent;\n            await this.store.deleteThreadItem(thread.id, removedEvent.item_id, context);\n            break;\n          }\n          case 'thread.item.replaced': {\n            const replacedEvent = event as ThreadItemReplacedEvent;\n            await this.store.saveItem(thread.id, replacedEvent.item, context);\n            break;\n          }\n        }\n\n        // Filter out hidden context items from client\n        const shouldSwallowEvent =\n          event.type === 'thread.item.done' &&\n          (event as ThreadItemDoneEvent).item.type === 'hidden_context_item';\n\n        if (!shouldSwallowEvent) {\n          yield event;\n        }\n\n        // Check if thread was updated\n        if (JSON.stringify(thread) !== JSON.stringify(lastThread)) {\n          lastThread = { ...thread } as ThreadMetadata;\n          await this.store.saveThread(thread, context);\n          yield {\n            type: 'thread.updated',\n            thread: this.toThreadResponse(thread),\n          } as ThreadUpdatedEvent;\n        }\n      }\n\n      // Final thread update check\n      if (JSON.stringify(thread) !== JSON.stringify(lastThread)) {\n        lastThread = { ...thread } as ThreadMetadata;\n        await this.store.saveThread(thread, context);\n        yield {\n          type: 'thread.updated',\n          thread: this.toThreadResponse(thread),\n        } as ThreadUpdatedEvent;\n      }\n    } catch (error) {\n      if (error instanceof CustomStreamError) {\n        yield {\n          type: 'error',\n          code: 'custom',\n          message: error.message,\n          allow_retry: error.allowRetry,\n        } as ErrorEvent;\n      } else if (error instanceof StreamError) {\n        yield {\n          type: 'error',\n          code: error.code,\n          allow_retry: error.allowRetry,\n        } as ErrorEvent;\n      } else {\n        yield {\n          type: 'error',\n          code: ErrorCode.STREAM_ERROR,\n          allow_retry: true,\n        } as ErrorEvent;\n        this.logger.error('Unhandled error in stream', { error });\n      }\n    }\n  }\n\n  /**\n   * Build a UserMessageItem from input\n   */\n  protected async buildUserMessageItem(\n    input: any,\n    thread: ThreadMetadata,\n    context: TContext\n  ): Promise<UserMessageItem> {\n    // Load attachments\n    const attachments = await Promise.all(\n      (input.attachments || []).map((id: string) => this.store.loadAttachment(id, context))\n    );\n\n    return {\n      type: 'user_message',\n      id: this.store.generateItemId('message', thread, context),\n      thread_id: thread.id,\n      created_at: new Date().toISOString(),\n      content: input.content,\n      attachments,\n      quoted_text: input.quoted_text || null,\n      inference_options: input.inference_options || {},\n    };\n  }\n\n  /**\n   * Load a full thread with items\n   */\n  protected async loadFullThread(threadId: string, context: TContext): Promise<Thread> {\n    const threadMeta = await this.store.loadThread(threadId, context);\n    const threadItems = await this.store.loadThreadItems(\n      threadId,\n      null,\n      DEFAULT_PAGE_SIZE,\n      'asc',\n      context\n    );\n\n    return {\n      ...threadMeta,\n      items: threadItems,\n    };\n  }\n\n  /**\n   * Convert ThreadMetadata or Thread to Thread response\n   * (filters out hidden context items)\n   */\n  protected toThreadResponse(thread: ThreadMetadata | Thread): Thread {\n    const isThread = (t: ThreadMetadata | Thread): t is Thread => 'items' in t;\n\n    const items: Page<any> = isThread(thread)\n      ? thread.items\n      : { data: [], has_more: false, after: null };\n\n    // Filter out hidden context items\n    items.data = items.data.filter((item: any) => item.type !== 'hidden_context_item');\n\n    return {\n      id: thread.id,\n      title: thread.title,\n      created_at: thread.created_at,\n      status: thread.status,\n      metadata: thread.metadata,\n      items,\n    };\n  }\n}\n","/**\n * Widget Streaming Helper Functions\n *\n * This module provides utilities for streaming and updating widgets,\n * including diff calculation and text accumulation from Agent SDK streams.\n */\n\nimport type { RunStreamEvent } from '@openai/agents';\nimport type {\n  WidgetRoot,\n  Text,\n  Markdown,\n} from '../widgets/index.js';\nimport type {\n  WidgetStreamingTextValueDelta,\n  WidgetRootUpdated,\n  WidgetComponentUpdated,\n} from '../types/events.js';\n\n/**\n * Compare two WidgetRoot structures and return a list of deltas.\n *\n * This function determines what has changed between two widget states and returns\n * the minimal set of updates needed to transform the `before` state into the `after` state.\n *\n * For Text and Markdown components with an `id`, it detects text value changes and\n * emits streaming text deltas if the new value is a prefix extension of the old value.\n *\n * @param before - The previous widget state\n * @param after - The new widget state\n * @returns Array of update events (text deltas, component updates, or full replacement)\n *\n * @example\n * ```typescript\n * const before: Card = { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Hello' }] };\n * const after: Card = { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Hello World' }] };\n * const deltas = diffWidget(before, after);\n * // Returns: [{ type: 'widget.streaming_text.value_delta', component_id: 'msg', delta: ' World', done: false }]\n * ```\n */\nexport function diffWidget(\n  before: WidgetRoot,\n  after: WidgetRoot\n): Array<WidgetStreamingTextValueDelta | WidgetRootUpdated | WidgetComponentUpdated> {\n  /**\n   * Check if a full replacement is needed (type, id, or key changed, or significant structural changes)\n   */\n  function needsFullReplace(before: any, after: any): boolean {\n    // Type mismatch\n    if (before.type !== after.type) {\n      return true;\n    }\n\n    // ID or key mismatch\n    if (before.id !== after.id || before.key !== after.key) {\n      return true;\n    }\n\n    // Check if any non-value properties changed significantly\n    const beforeKeys = new Set(Object.keys(before));\n    const afterKeys = new Set(Object.keys(after));\n    const allKeys = new Set([...beforeKeys, ...afterKeys]);\n\n    for (const key of allKeys) {\n      // Skip 'value' for Text/Markdown - we handle that specially\n      if (\n        (before.type === 'Text' || before.type === 'Markdown') &&\n        key === 'value' &&\n        typeof after.value === 'string' &&\n        typeof before.value === 'string' &&\n        after.value.startsWith(before.value)\n      ) {\n        continue;\n      }\n\n      const beforeVal = before[key];\n      const afterVal = after[key];\n\n      // Handle arrays\n      if (Array.isArray(beforeVal) && Array.isArray(afterVal)) {\n        if (beforeVal.length !== afterVal.length) {\n          return true;\n        }\n        for (let i = 0; i < beforeVal.length; i++) {\n          if (typeof beforeVal[i] === 'object' && typeof afterVal[i] === 'object') {\n            if (needsFullReplace(beforeVal[i], afterVal[i])) {\n              return true;\n            }\n          } else if (beforeVal[i] !== afterVal[i]) {\n            return true;\n          }\n        }\n      }\n      // Handle objects\n      else if (\n        typeof beforeVal === 'object' &&\n        beforeVal !== null &&\n        typeof afterVal === 'object' &&\n        afterVal !== null\n      ) {\n        if (needsFullReplace(beforeVal, afterVal)) {\n          return true;\n        }\n      }\n      // Primitive comparison\n      else if (beforeVal !== afterVal) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If full replace needed, return root update\n  if (needsFullReplace(before, after)) {\n    return [\n      {\n        type: 'widget.root.updated',\n        widget: after,\n      },\n    ];\n  }\n\n  // Find all Text/Markdown components with IDs\n  const deltas: Array<WidgetStreamingTextValueDelta | WidgetComponentUpdated | WidgetRootUpdated> =\n    [];\n\n  function findAllStreamingTextComponents(component: any): Map<string, Text | Markdown> {\n    const components = new Map<string, Text | Markdown>();\n\n    function recurse(comp: any): void {\n      if (\n        comp &&\n        typeof comp === 'object' &&\n        (comp.type === 'Text' || comp.type === 'Markdown') &&\n        comp.id\n      ) {\n        components.set(comp.id, comp);\n      }\n\n      if (comp && typeof comp === 'object' && comp.children) {\n        const children = Array.isArray(comp.children) ? comp.children : [];\n        for (const child of children) {\n          recurse(child);\n        }\n      }\n    }\n\n    recurse(component);\n    return components;\n  }\n\n  const beforeNodes = findAllStreamingTextComponents(before);\n  const afterNodes = findAllStreamingTextComponents(after);\n\n  // Check each after node for changes\n  for (const [id, afterNode] of afterNodes) {\n    const beforeNode = beforeNodes.get(id);\n\n    if (!beforeNode) {\n      throw new Error(\n        `Node ${id} was not present when the widget was initially rendered. ` +\n          `All nodes with ID must persist across all widget updates.`\n      );\n    }\n\n    const beforeValue = beforeNode.value || '';\n    const afterValue = afterNode.value || '';\n\n    if (beforeValue !== afterValue) {\n      // Check if it's a valid streaming update (must be prefix)\n      if (!afterValue.startsWith(beforeValue)) {\n        throw new Error(\n          `Node ${id} was updated with a new value that is not a prefix of the initial value. ` +\n            `All widget updates must be cumulative.`\n        );\n      }\n\n      const delta = afterValue.slice(beforeValue.length);\n      const done = !afterNode.streaming;\n\n      deltas.push({\n        type: 'widget.streaming_text.value_delta',\n        component_id: id,\n        delta,\n        done,\n      });\n    }\n  }\n\n  return deltas;\n}\n\n/**\n * Accumulate text from Agent SDK stream events into a Text or Markdown widget.\n *\n * This helper function listens to Agent SDK `output_text_delta` events and progressively\n * updates the widget's value property, yielding new widget states as text accumulates.\n *\n * @template TWidget - Type of widget (Text or Markdown)\n * @param events - Async iterable of Agent SDK RunStreamEvents\n * @param baseWidget - Initial widget to accumulate text into (must have id and streaming: true)\n * @returns Async generator yielding updated widget states\n *\n * @example\n * ```typescript\n * const agentRun = Runner.runStreamed(agent, input);\n *\n * for await (const textWidget of accumulateText(\n *   agentRun.streamEvents(),\n *   { type: 'Text', id: 'output', value: '', streaming: true }\n * )) {\n *   const card: Card = { type: 'Card', children: [textWidget] };\n *   yield card; // Emit updated widget with accumulated text\n * }\n * ```\n */\nexport async function* accumulateText<TWidget extends Text | Markdown>(\n  events: AsyncIterable<RunStreamEvent>,\n  baseWidget: TWidget\n): AsyncGenerator<TWidget> {\n  let accumulatedText = '';\n\n  // Yield initial state\n  yield baseWidget;\n\n  for await (const event of events) {\n    if (event.type === 'raw_model_stream_event') {\n      const { data } = event;\n\n      if (data.type === 'output_text_delta') {\n        const delta = data.delta || '';\n        accumulatedText += delta;\n\n        // Yield updated widget with accumulated text\n        yield {\n          ...baseWidget,\n          value: accumulatedText,\n          streaming: true,\n        } as TWidget;\n      }\n    }\n  }\n\n  // Yield final state with streaming: false\n  yield {\n    ...baseWidget,\n    value: accumulatedText,\n    streaming: false,\n  } as TWidget;\n}\n","/**\n * ID generation utilities for threads, items, and attachments\n */\n\nimport type { StoreItemType } from '../types/store.js';\n\n/**\n * Generate a random ID with the given prefix.\n * Format: {prefix}_{8 random hex characters}\n * Example: \"thr_a1b2c3d4\" or \"msg_1a2b3c4d\"\n */\nexport function generateId(prefix: string): string {\n  const randomHex = Math.random().toString(16).substring(2, 10).padStart(8, '0');\n  return `${prefix}_${randomHex}`;\n}\n\n/**\n * Generate a thread ID.\n * Default implementation: Returns generateId('thr')\n */\nexport function defaultGenerateThreadId(): string {\n  return generateId('thr');\n}\n\n/**\n * Generate an item ID based on the item type.\n * Maps type to prefix:\n * - 'message'  'msg'\n * - 'tool_call'  'tc'\n * - 'task'  'task'\n * - 'workflow'  'wf'\n * - 'attachment'  'atc'\n */\nexport function defaultGenerateItemId(type: StoreItemType): string {\n  const prefixMap: Record<StoreItemType, string> = {\n    message: 'msg',\n    tool_call: 'tc',\n    task: 'task',\n    workflow: 'wf',\n    attachment: 'atc',\n  };\n\n  const prefix = prefixMap[type];\n  return generateId(prefix);\n}\n\n/**\n * Generate an attachment ID.\n * Default implementation: Returns generateId('atc')\n */\nexport function defaultGenerateAttachmentId(): string {\n  return generateId('atc');\n}\n","/**\n * Standalone Widget Streaming\n *\n * This module provides a standalone `streamWidget` function for use in the\n * ChatKitServer's `respond()` method. It converts widgets to ChatKit thread events,\n * handling both static widgets and streaming widget generators.\n */\n\nimport type { ThreadMetadata } from '../types/thread.js';\nimport type { ThreadStreamEvent } from '../types/events.js';\nimport type { WidgetItem } from '../types/items.js';\nimport type { WidgetRoot } from '../widgets/index.js';\nimport { diffWidget } from '../agents/widget-helpers.js';\nimport { defaultGenerateItemId } from '../utils/id.js';\n\n/**\n * Stream a widget as ChatKit thread events.\n *\n * This function can be used directly in the `respond()` method to emit widgets\n * without requiring an AgentContext. It supports both:\n * - Static widgets: Emits a single `thread.item.done` event\n * - Streaming widgets: Emits `thread.item.added`, `thread.item.updated`, and `thread.item.done` events\n *\n * For streaming widgets, Text and Markdown components with an `id` will have their\n * value changes emitted as text delta events for a smooth streaming experience.\n *\n * @param thread - The current thread metadata\n * @param widget - Static widget or async generator yielding widget states\n * @param copyText - Optional text for copy-to-clipboard functionality\n * @param generateId - Optional function to generate item IDs (defaults to defaultGenerateItemId)\n * @returns Async generator of ThreadStreamEvents\n *\n * @example\n * ```typescript\n * // In ChatKitServer.respond():\n * async function* respond(thread, input, context) {\n *   // Static widget\n *   for await (const event of streamWidget(thread, {\n *     type: 'Card',\n *     children: [{ type: 'Text', value: 'Hello!' }]\n *   })) {\n *     yield event;\n *   }\n *\n *   // Streaming widget\n *   async function* widgetGen() {\n *     yield { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Loading...', streaming: true }] };\n *     await delay(1000);\n *     yield { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Complete!', streaming: false }] };\n *   }\n *   for await (const event of streamWidget(thread, widgetGen())) {\n *     yield event;\n *   }\n * }\n * ```\n */\nexport async function* streamWidget(\n  thread: ThreadMetadata,\n  widget: WidgetRoot | AsyncGenerator<WidgetRoot, void, undefined>,\n  copyText?: string | null,\n  generateId: (itemType: 'message' | 'workflow' | 'task' | 'tool_call' | 'attachment') => string = (\n    itemType\n  ) => defaultGenerateItemId(itemType)\n): AsyncGenerator<ThreadStreamEvent> {\n  const itemId = generateId('message');\n\n  // Handle static widget (not a generator)\n  if (\n    typeof widget === 'object' &&\n    widget !== null &&\n    !('next' in widget && typeof widget.next === 'function')\n  ) {\n    const widgetItem: WidgetItem = {\n      type: 'widget',\n      id: itemId,\n      thread_id: thread.id,\n      created_at: new Date().toISOString(),\n      widget: widget as WidgetRoot,\n      copy_text: copyText || null,\n    };\n\n    yield {\n      type: 'thread.item.done',\n      item: widgetItem,\n    };\n    return;\n  }\n\n  // Handle streaming widget generator\n  const widgetGen = widget as AsyncGenerator<WidgetRoot, void, undefined>;\n\n  // Get initial state\n  const initialResult = await widgetGen.next();\n  if (initialResult.done) {\n    return; // Empty generator\n  }\n\n  const initialState = initialResult.value;\n\n  const widgetItem: WidgetItem = {\n    type: 'widget',\n    id: itemId,\n    thread_id: thread.id,\n    created_at: new Date().toISOString(),\n    widget: initialState,\n    copy_text: copyText || null,\n  };\n\n  // Emit initial item added\n  yield {\n    type: 'thread.item.added',\n    item: widgetItem,\n  };\n\n  let lastState = initialState;\n\n  // Stream updates\n  for await (const newState of widgetGen) {\n    const deltas = diffWidget(lastState, newState);\n\n    for (const update of deltas) {\n      yield {\n        type: 'thread.item.updated',\n        item_id: itemId,\n        update,\n      };\n    }\n\n    lastState = newState;\n  }\n\n  // Emit final done event with last state\n  yield {\n    type: 'thread.item.done',\n    item: {\n      ...widgetItem,\n      widget: lastState,\n    },\n  };\n}\n","/**\n * Store - Abstract storage interface for ChatKit server\n *\n * Users must implement this interface to provide persistence for threads,\n * items, and attachments. Can use any storage backend (memory, SQL, NoSQL, etc.)\n */\n\nimport type {\n  ThreadMetadata,\n  ThreadItem,\n  Attachment,\n  Page,\n  StoreItemType,\n} from '../types/index.js';\nimport { defaultGenerateThreadId, defaultGenerateItemId } from '../utils/id.js';\n\nexport class NotFoundError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'NotFoundError';\n  }\n}\n\n/**\n * Abstract Store class\n *\n * Implement all abstract methods to provide persistence for your ChatKit server.\n *\n * @example\n * ```typescript\n * class MyStore extends Store<{ userId: string }> {\n *   async loadThread(threadId, context) {\n *     // Load from database\n *   }\n *   // ... implement other methods\n * }\n * ```\n */\nexport abstract class Store<TContext = unknown> {\n  /**\n   * Generate a thread ID\n   *\n   * Override to customize ID format. Default: 'thr_' + 8 random hex chars\n   */\n  generateThreadId(_context: TContext): string {\n    return defaultGenerateThreadId();\n  }\n\n  /**\n   * Generate an item ID\n   *\n   * Override to customize ID format. Default: type-specific prefix + 8 random hex chars\n   */\n  generateItemId(type: StoreItemType, _thread: ThreadMetadata, _context: TContext): string {\n    return defaultGenerateItemId(type);\n  }\n\n  // ============================================================================\n  // Thread Methods (Must Implement)\n  // ============================================================================\n\n  /**\n   * Load a thread by ID\n   *\n   * @throws NotFoundError if thread doesn't exist\n   */\n  abstract loadThread(threadId: string, context: TContext): Promise<ThreadMetadata>;\n\n  /**\n   * Save a thread (insert or update)\n   */\n  abstract saveThread(thread: ThreadMetadata, context: TContext): Promise<void>;\n\n  /**\n   * Delete a thread and all its items\n   */\n  abstract deleteThread(threadId: string, context: TContext): Promise<void>;\n\n  /**\n   * Load a paginated list of threads\n   *\n   * @param limit - Max number of threads to return\n   * @param after - Cursor for pagination (null for first page)\n   * @param order - Sort order: 'asc' or 'desc' by created_at\n   * @param context - Request context\n   */\n  abstract loadThreads(\n    limit: number,\n    after: string | null,\n    order: 'asc' | 'desc',\n    context: TContext\n  ): Promise<Page<ThreadMetadata>>;\n\n  // ============================================================================\n  // Item Methods (Must Implement)\n  // ============================================================================\n\n  /**\n   * Load items for a thread\n   *\n   * @param threadId - Thread ID\n   * @param after - Cursor for pagination (null for first page)\n   * @param limit - Max number of items to return\n   * @param order - Sort order: 'asc' or 'desc' by created_at\n   * @param context - Request context\n   */\n  abstract loadThreadItems(\n    threadId: string,\n    after: string | null,\n    limit: number,\n    order: 'asc' | 'desc',\n    context: TContext\n  ): Promise<Page<ThreadItem>>;\n\n  /**\n   * Add a new item to a thread\n   */\n  abstract addThreadItem(\n    threadId: string,\n    item: ThreadItem,\n    context: TContext\n  ): Promise<void>;\n\n  /**\n   * Update an existing item\n   */\n  abstract saveItem(threadId: string, item: ThreadItem, context: TContext): Promise<void>;\n\n  /**\n   * Load a specific item\n   *\n   * @throws NotFoundError if item doesn't exist\n   */\n  abstract loadItem(\n    threadId: string,\n    itemId: string,\n    context: TContext\n  ): Promise<ThreadItem>;\n\n  /**\n   * Delete an item from a thread\n   */\n  abstract deleteThreadItem(\n    threadId: string,\n    itemId: string,\n    context: TContext\n  ): Promise<void>;\n\n  // ============================================================================\n  // Attachment Methods (Must Implement)\n  // ============================================================================\n\n  /**\n   * Save attachment metadata\n   */\n  abstract saveAttachment(attachment: Attachment, context: TContext): Promise<void>;\n\n  /**\n   * Load attachment metadata\n   *\n   * @throws NotFoundError if attachment doesn't exist\n   */\n  abstract loadAttachment(attachmentId: string, context: TContext): Promise<Attachment>;\n\n  /**\n   * Delete attachment metadata\n   */\n  abstract deleteAttachment(attachmentId: string, context: TContext): Promise<void>;\n}\n","/**\n * AttachmentStore - Abstract interface for file attachment storage\n *\n * Handles the storage and retrieval of file attachments (images, documents, etc.)\n * Separate from Store to allow different storage backends (S3, local, etc.)\n */\n\nimport type { Attachment, AttachmentCreateParams } from '../types/index.js';\nimport { defaultGenerateAttachmentId } from '../utils/id.js';\n\n/**\n * Abstract AttachmentStore class\n *\n * Implement to provide file storage for attachments.\n *\n * @example\n * ```typescript\n * class S3AttachmentStore extends AttachmentStore<{ userId: string }> {\n *   async createAttachment(params, context) {\n *     // Generate presigned S3 URL\n *     // Return attachment with upload_url\n *   }\n *\n *   async deleteAttachment(attachmentId, context) {\n *     // Delete from S3\n *   }\n * }\n * ```\n */\nexport abstract class AttachmentStore<TContext = unknown> {\n  /**\n   * Generate an attachment ID\n   *\n   * Override to customize ID format. Default: 'atc_' + 8 random hex chars\n   */\n  generateAttachmentId(_mimeType: string, _context: TContext): string {\n    return defaultGenerateAttachmentId();\n  }\n\n  /**\n   * Create an attachment and return upload URL\n   *\n   * For two-phase upload pattern:\n   * 1. Client calls attachments.create to get upload_url\n   * 2. Client uploads file to upload_url\n   * 3. File is now available at the attachment's permanent URL\n   *\n   * @param params - Attachment metadata (name, size, mime_type)\n   * @param context - Request context\n   * @returns Attachment with upload_url for client to upload to\n   */\n  abstract createAttachment(\n    params: AttachmentCreateParams,\n    context: TContext\n  ): Promise<Attachment>;\n\n  /**\n   * Delete an attachment file\n   *\n   * Called when attachment is deleted. Should remove the file from storage.\n   *\n   * @param attachmentId - Attachment ID\n   * @param context - Request context\n   */\n  abstract deleteAttachment(attachmentId: string, context: TContext): Promise<void>;\n}\n","/**\n * ChatKit Agents SDK Integration\n *\n * This module provides integration helpers for using the OpenAI Agents SDK\n * with ChatKit. It bridges the gap between Agent Runner streams and ChatKit\n * ThreadStreamEvents, making it easy to build agent-powered chat applications.\n *\n * Includes support for:\n * - Agent response streaming\n * - Widget streaming from tools\n * - Event merging (multi-agent workflows)\n * - Thread item conversion\n *\n * @module agents\n */\n\n// Core types and context\nexport type { AgentContext } from './types.js';\nexport { AsyncEventQueue } from './types.js';\nexport { createAgentContext } from './context-helpers.js';\n\n// Input/output conversion\nexport { simpleToAgentInput } from './input-converter.js';\nexport { streamAgentResponse } from './stream-converter.js';\n\n// Output conversion (Agent  ChatKit ThreadItems)\nexport {\n  ThreadItemConverter,\n  DefaultThreadItemConverter,\n} from './item-converter.js';\n\n// Input conversion (ChatKit ThreadItems  Agent input) - NEW!\nexport {\n  InputThreadItemConverter,\n  defaultInputConverter,\n  type ResponseInputItem,\n  type ResponseInputMessage,\n  type ResponseInputContentParam,\n  type ResponseInputTextParam,\n  type ResponseInputImageParam,\n  type ResponseFunctionToolCall,\n  type ResponseFunctionCallOutput,\n} from './input-item-converter.js';\n\n// Widget helpers\nexport { diffWidget, accumulateText } from './widget-helpers.js';\n\n// Stream merging (for advanced use cases)\nexport { mergeAsyncGenerators, EventWrapper } from './merge-streams.js';\n","import type { ThreadMetadata } from '../types/thread.js';\nimport type { Store } from '../store/Store.js';\nimport type { StoreItemType } from '../types/store.js';\nimport type { ThreadStreamEvent } from '../types/events.js';\nimport type { WidgetRoot } from '../widgets/index.js';\nimport type { WorkflowItem } from '../types/items.js';\nimport type { Workflow, Task, WorkflowSummary } from '../types/workflow.js';\n\n/**\n * Client tool call configuration.\n * Set this on AgentContext to trigger a client-side tool execution.\n */\nexport interface ClientToolCall {\n  /** Name of the client-side tool to call */\n  name: string;\n  /** Arguments to pass to the client tool */\n  arguments: Record<string, any>;\n}\n\n/**\n * Async queue for managing custom events in AgentContext.\n * Implements AsyncIterable so it can be consumed as an async generator.\n */\nexport class AsyncEventQueue<T> implements AsyncIterable<T> {\n  private queue: T[] = [];\n  private resolvers: Array<(value: T | typeof AsyncEventQueue.COMPLETE) => void> = [];\n  private completed = false;\n\n  static COMPLETE = Symbol('COMPLETE');\n\n  /**\n   * Add an event to the queue\n   */\n  push(event: T): void {\n    if (this.completed) {\n      throw new Error('Cannot push to completed queue');\n    }\n\n    if (this.resolvers.length > 0) {\n      // Someone is waiting, resolve immediately\n      const resolve = this.resolvers.shift()!;\n      resolve(event);\n    } else {\n      // No one waiting, queue it\n      this.queue.push(event);\n    }\n  }\n\n  /**\n   * Mark the queue as complete\n   */\n  complete(): void {\n    this.completed = true;\n    // Resolve all waiting consumers with COMPLETE sentinel\n    for (const resolve of this.resolvers) {\n      resolve(AsyncEventQueue.COMPLETE);\n    }\n    this.resolvers = [];\n  }\n\n  /**\n   * Get next event from queue (async)\n   */\n  private next(): Promise<T | typeof AsyncEventQueue.COMPLETE> {\n    if (this.queue.length > 0) {\n      return Promise.resolve(this.queue.shift()!);\n    }\n\n    if (this.completed) {\n      return Promise.resolve(AsyncEventQueue.COMPLETE);\n    }\n\n    // Wait for next push\n    return new Promise((resolve) => {\n      this.resolvers.push(resolve);\n    });\n  }\n\n  /**\n   * Implement AsyncIterable\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<T> {\n    while (true) {\n      const value = await this.next();\n      if (value === AsyncEventQueue.COMPLETE) {\n        break;\n      }\n      // Type guard: if not COMPLETE, it must be T\n      yield value as T;\n    }\n  }\n}\n\n/**\n * Context object passed to Agent execution that combines ChatKit-specific data\n * with user-defined request context.\n *\n * This allows Agents to access the current thread, store, and any custom\n * context data (like user ID, tenant ID, etc.) during execution.\n *\n * Provides methods for tools to emit custom events (widgets, workflows, etc.)\n * that will be merged with Agent SDK response streams.\n *\n * @template TContext - The user-defined context type (default: unknown)\n *\n * @example\n * ```typescript\n * interface MyContext {\n *   userId: string;\n *   tenantId: string;\n * }\n *\n * const agentContext: AgentContext<MyContext> = {\n *   thread: currentThread,\n *   store: myStore,\n *   requestContext: { userId: 'user123', tenantId: 'tenant456' },\n *   _events: new AsyncEventQueue()\n * };\n *\n * // In a tool:\n * await agentContext.streamWidget(myWidget);\n * ```\n */\nexport interface AgentContext<TContext = unknown> {\n  /** The current ChatKit thread being processed */\n  thread: ThreadMetadata;\n\n  /** The store instance for persisting thread data */\n  store: Store<TContext>;\n\n  /** User-defined request context (e.g., user ID, session data, etc.) */\n  requestContext: TContext;\n\n  /**\n   * Internal event queue for custom events (widgets, workflows, etc.)\n   * @internal\n   */\n  _events: AsyncEventQueue<ThreadStreamEvent>;\n\n  /**\n   * Previous response ID for conversation chaining.\n   * Used with OpenAI's Responses API to maintain server-side conversation state.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @example\n   * ```typescript\n   * // Track response ID for next request\n   * context.previousResponseId = result.response_id;\n   * ```\n   */\n  previousResponseId?: string | null;\n\n  /**\n   * Current active workflow item.\n   * Tracks custom workflows created by tools during execution.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @example\n   * ```typescript\n   * // Start a workflow\n   * await context.startWorkflow({ type: 'custom', tasks: [] });\n   * console.log(context.workflowItem?.id); // \"wf_abc123\"\n   * ```\n   */\n  workflowItem?: WorkflowItem | null;\n\n  /**\n   * Client tool call to be executed on the client-side.\n   * When set by a tool, this will be emitted as a ClientToolCallItem at the end of the stream.\n   *\n   * @example\n   * ```typescript\n   * // In a tool's execute function:\n   * context.clientToolCall = {\n   *   name: 'add_to_todo_list',\n   *   arguments: { task: 'Buy groceries' }\n   * };\n   * ```\n   */\n  clientToolCall?: ClientToolCall;\n\n  /**\n   * Generate a unique ID for a thread item.\n   *\n   * Convenience method for generating IDs without calling store methods directly.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @param type - The type of item to generate an ID for\n   * @param thread - Optional thread metadata (defaults to context.thread)\n   * @returns A unique ID string\n   *\n   * @example\n   * ```typescript\n   * const itemId = context.generateId('message');\n   * const workflowId = context.generateId('workflow');\n   * ```\n   */\n  generateId(type: StoreItemType, thread?: ThreadMetadata): string;\n\n  /**\n   * Start a new workflow.\n   *\n   * Workflows are multi-step progress indicators shown to users.\n   * Use this to create custom workflows that display task progress.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @param workflow - The workflow configuration\n   *\n   * @example\n   * ```typescript\n   * // In a tool that processes data\n   * async execute(params, { context }) {\n   *   await context.startWorkflow({\n   *     type: 'custom',\n   *     tasks: [],\n   *     expanded: true,\n   *     summary: null\n   *   });\n   *\n   *   // Add tasks as work progresses...\n   * }\n   * ```\n   */\n  startWorkflow(workflow: Workflow): Promise<void>;\n\n  /**\n   * End the current workflow.\n   *\n   * Completes the active workflow with an optional summary.\n   * The workflow will be saved to the database and marked as complete.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @param summary - Optional summary to display when collapsed\n   * @param expanded - Whether to keep the workflow expanded (default: false)\n   *\n   * @example\n   * ```typescript\n   * // End workflow with duration summary\n   * await context.endWorkflow(\n   *   { type: 'duration', duration: 30 },\n   *   false  // collapsed\n   * );\n   * ```\n   */\n  endWorkflow(\n    summary?: WorkflowSummary | null,\n    expanded?: boolean\n  ): Promise<void>;\n\n  /**\n   * Add a task to the current workflow.\n   *\n   * Creates or updates the active workflow with a new task.\n   * If no workflow is active, creates one automatically.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @param task - The task to add to the workflow\n   *\n   * @example\n   * ```typescript\n   * await context.addWorkflowTask({\n   *   type: 'custom',\n   *   title: 'Loading data',\n   *   content: 'Reading 1000 rows from database...'\n   * });\n   *\n   * // Later, update it\n   * await context.updateWorkflowTask(\n   *   { type: 'custom', title: 'Loading data', content: ' Loaded 1000 rows' },\n   *   0  // task index\n   * );\n   * ```\n   */\n  addWorkflowTask(task: Task): Promise<void>;\n\n  /**\n   * Update an existing task in the current workflow.\n   *\n   * Modifies a task at the specified index, useful for showing progress updates.\n   *\n   * NEW: Python SDK parity feature!\n   *\n   * @param task - The updated task\n   * @param taskIndex - The index of the task to update\n   *\n   * @example\n   * ```typescript\n   * // Update task status from \"in progress\" to \"complete\"\n   * await context.updateWorkflowTask(\n   *   {\n   *     type: 'custom',\n   *     title: 'Processing',\n   *     content: ' Completed 100/100 items'\n   *   },\n   *   1  // second task\n   * );\n   * ```\n   */\n  updateWorkflowTask(task: Task, taskIndex: number): Promise<void>;\n\n  /**\n   * Emit a custom ThreadStreamEvent.\n   * This is typically used by tools to send custom events alongside Agent SDK responses.\n   *\n   * @param event - The ThreadStreamEvent to emit\n   *\n   * @example\n   * ```typescript\n   * await context.stream({\n   *   type: 'thread.item.added',\n   *   item: myCustomItem\n   * });\n   * ```\n   */\n  stream(event: ThreadStreamEvent): Promise<void>;\n\n  /**\n   * Stream a widget to the chat interface.\n   * Can accept either a static widget or an async generator for streaming updates.\n   *\n   * @param widget - Static widget or async generator yielding widget states\n   * @param copyText - Optional text for copy-to-clipboard functionality\n   *\n   * @example\n   * ```typescript\n   * // Static widget\n   * await context.streamWidget({\n   *   type: 'Card',\n   *   children: [{ type: 'Text', value: 'Hello!' }]\n   * });\n   *\n   * // Streaming widget\n   * async function* widgetGenerator() {\n   *   yield { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Loading...' }] };\n   *   yield { type: 'Card', children: [{ type: 'Text', id: 'msg', value: 'Complete!' }] };\n   * }\n   * await context.streamWidget(widgetGenerator());\n   * ```\n   */\n  streamWidget(\n    widget: WidgetRoot | AsyncGenerator<WidgetRoot, void, undefined>,\n    copyText?: string | null\n  ): Promise<void>;\n}\n","/**\n * AgentContext Helper Functions\n *\n * This module provides helper functions to create and work with AgentContext instances.\n */\n\nimport type { ThreadMetadata } from '../types/thread.js';\nimport type { Store } from '../store/Store.js';\nimport type { ThreadStreamEvent } from '../types/events.js';\nimport type { WidgetRoot } from '../widgets/index.js';\nimport type { AgentContext } from './types.js';\nimport type { WorkflowItem } from '../types/items.js';\nimport type { Workflow, Task, WorkflowSummary } from '../types/workflow.js';\nimport { AsyncEventQueue } from './types.js';\nimport { streamWidget as serverStreamWidget } from '../server/widget-stream.js';\n\n/**\n * Create an AgentContext with all required methods implemented.\n *\n * This factory function creates a complete AgentContext instance with the\n * stream() and streamWidget() methods properly implemented.\n *\n * @template TContext - The user-defined context type\n * @param thread - The current thread metadata\n * @param store - The store instance\n * @param requestContext - User-defined request context\n * @returns A complete AgentContext instance\n *\n * @example\n * ```typescript\n * const context = createAgentContext(\n *   currentThread,\n *   myStore,\n *   { userId: 'user123' }\n * );\n *\n * // Use in tools:\n * await context.streamWidget(myWidget);\n * ```\n */\nexport function createAgentContext<TContext = unknown>(\n  thread: ThreadMetadata,\n  store: Store<TContext>,\n  requestContext: TContext\n): AgentContext<TContext> {\n  const _events = new AsyncEventQueue<ThreadStreamEvent>();\n\n  const context: AgentContext<TContext> = {\n    thread,\n    store,\n    requestContext,\n    _events,\n\n    // NEW: Python SDK parity fields\n    previousResponseId: null,\n    workflowItem: null,\n\n    // Convenience ID generation\n    generateId(type, thread?) {\n      const targetThread = thread || context.thread;\n      return store.generateItemId(type, targetThread, requestContext);\n    },\n\n    // Workflow management methods\n    async startWorkflow(workflow: Workflow): Promise<void> {\n      const workflowItem: WorkflowItem = {\n        type: 'workflow',\n        id: context.generateId('workflow'),\n        thread_id: context.thread.id,\n        created_at: new Date().toISOString(),\n        workflow,\n      };\n\n      context.workflowItem = workflowItem;\n\n      // Defer sending added event until tasks are added for non-reasoning workflows\n      if (workflow.type !== 'reasoning' && workflow.tasks.length === 0) {\n        return;\n      }\n\n      await context.stream({\n        type: 'thread.item.added',\n        item: workflowItem,\n      });\n    },\n\n    async endWorkflow(\n      summary?: WorkflowSummary | null,\n      expanded: boolean = false\n    ): Promise<void> {\n      if (!context.workflowItem) {\n        return; // No workflow to end\n      }\n\n      // Set summary if provided\n      if (summary !== undefined) {\n        context.workflowItem.workflow.summary = summary;\n      } else if (context.workflowItem.workflow.summary === null) {\n        // Calculate duration if no summary provided\n        const start = new Date(context.workflowItem.created_at).getTime();\n        const end = Date.now();\n        const duration = Math.floor((end - start) / 1000);\n        context.workflowItem.workflow.summary = {\n          duration,\n        };\n      }\n\n      context.workflowItem.workflow.expanded = expanded;\n\n      await context.stream({\n        type: 'thread.item.done',\n        item: context.workflowItem,\n      });\n\n      context.workflowItem = null;\n    },\n\n    async addWorkflowTask(task: Task): Promise<void> {\n      // Create workflow if needed\n      if (!context.workflowItem) {\n        await context.startWorkflow({\n          type: 'custom',\n          tasks: [],\n          expanded: true,\n          summary: null,\n        });\n      }\n\n      const workflow = context.workflowItem!.workflow;\n      workflow.tasks.push(task);\n\n      // Send added event if this is the first task for a non-reasoning workflow\n      if (workflow.type !== 'reasoning' && workflow.tasks.length === 1) {\n        await context.stream({\n          type: 'thread.item.added',\n          item: context.workflowItem!,\n        });\n      } else {\n        // Send task added update\n        await context.stream({\n          type: 'thread.item.updated',\n          item_id: context.workflowItem!.id,\n          update: {\n            type: 'workflow.task.added',\n            task_index: workflow.tasks.length - 1,\n            task,\n          },\n        });\n      }\n    },\n\n    async updateWorkflowTask(task: Task, taskIndex: number): Promise<void> {\n      if (!context.workflowItem) {\n        throw new Error('No active workflow to update');\n      }\n\n      const workflow = context.workflowItem.workflow;\n\n      if (taskIndex < 0 || taskIndex >= workflow.tasks.length) {\n        throw new Error(`Task index ${taskIndex} out of bounds (workflow has ${workflow.tasks.length} tasks)`);\n      }\n\n      // Update task in place\n      workflow.tasks[taskIndex] = task;\n\n      await context.stream({\n        type: 'thread.item.updated',\n        item_id: context.workflowItem.id,\n        update: {\n          type: 'workflow.task.updated',\n          task_index: taskIndex,\n          task,\n        },\n      });\n    },\n\n    async stream(event: ThreadStreamEvent): Promise<void> {\n      _events.push(event);\n    },\n\n    async streamWidget(\n      widget: WidgetRoot | AsyncGenerator<WidgetRoot, void, undefined>,\n      copyText?: string | null\n    ): Promise<void> {\n      // Use the server streamWidget function and push events to queue\n      for await (const event of serverStreamWidget(\n        thread,\n        widget,\n        copyText,\n        (itemType) => store.generateItemId(itemType, thread, requestContext)\n      )) {\n        _events.push(event);\n      }\n    },\n  };\n\n  return context;\n}\n","/**\n * Input Thread Item Converter\n *\n * Converts ChatKit ThreadItems to Agent SDK input format.\n * This is the INPUT direction (Database  Agent).\n *\n * This is the missing piece from the TypeScript SDK that exists in Python SDK.\n * Enables the AI to see widgets, workflows, and tasks from conversation history.\n *\n * Based on: chatkit-python/chatkit/agents.py lines 628-933\n */\n\nimport type {\n  ThreadItem,\n  UserMessageItem,\n  AssistantMessageItem,\n  WidgetItem,\n  WorkflowItem,\n  TaskItem,\n  ClientToolCallItem,\n  EndOfTurnItem,\n  HiddenContextItem,\n  UserMessageContent,\n} from '../types/items.js';\nimport type { Attachment } from '../types/attachments.js';\n\n/**\n * Type representing Agent SDK input items.\n * Matches OpenAI Responses API input format.\n */\nexport type ResponseInputItem =\n  | ResponseInputMessage\n  | ResponseFunctionToolCall\n  | ResponseFunctionCallOutput;\n\nexport interface ResponseInputMessage {\n  type: 'message';\n  role: 'user' | 'assistant';\n  content: ResponseInputContentParam[];\n}\n\nexport type ResponseInputContentParam =\n  | ResponseInputTextParam\n  | ResponseInputImageParam;\n\nexport interface ResponseInputTextParam {\n  type: 'input_text';\n  text: string;\n}\n\nexport interface ResponseInputImageParam {\n  type: 'input_image';\n  source: {\n    type: 'url';\n    url: string;\n  };\n}\n\nexport interface ResponseFunctionToolCall {\n  type: 'function_call';\n  call_id: string;\n  name: string;\n  arguments: string;\n}\n\nexport interface ResponseFunctionCallOutput {\n  type: 'function_call_output';\n  call_id: string;\n  output: string;\n}\n\n/**\n * Converts ChatKit thread items to Agent SDK input format.\n *\n * This class provides the missing INPUT conversion functionality that exists\n * in Python SDK but was missing in TypeScript SDK.\n *\n * Key capabilities:\n * - Convert widgets to descriptive text for the AI\n * - Convert workflows to task summaries\n * - Convert full thread history to agent input\n * - Handle attachments, tags, and special content types\n *\n * @example Basic usage\n * ```typescript\n * const converter = new InputThreadItemConverter();\n *\n * // Load thread history\n * const items = await store.loadThreadItems(threadId, null, 50, 'asc', context);\n *\n * // Convert to agent input\n * const agentInput = await converter.toAgentInput(items.data);\n *\n * // Pass to Agent SDK\n * const result = await run(agent, agentInput, { context });\n * ```\n *\n * @example Custom attachment handling\n * ```typescript\n * class MyConverter extends InputThreadItemConverter {\n *   async attachmentToMessageContent(attachment: Attachment): Promise<ResponseInputContentParam> {\n *     if (attachment.mime_type.startsWith('image/')) {\n *       return {\n *         type: 'input_image',\n *         source: { type: 'url', url: attachment.url }\n *       };\n *     }\n *     return {\n *       type: 'input_text',\n *       text: `[File: ${attachment.filename}]`\n *     };\n *   }\n * }\n * ```\n */\nexport class InputThreadItemConverter {\n  /**\n   * Convert an attachment to message content.\n   *\n   * REQUIRED when attachments are used in your application.\n   * Override this method to handle your attachment storage system.\n   *\n   * @param attachment - The attachment to convert\n   * @returns Message content representing the attachment\n   * @throws Error if not implemented and attachments are present\n   */\n  async attachmentToMessageContent(\n    _attachment: Attachment\n  ): Promise<ResponseInputContentParam> {\n    throw new Error(\n      'An Attachment was included in a UserMessageItem but ' +\n      'InputThreadItemConverter.attachmentToMessageContent() was not implemented. ' +\n      'Override this method to handle attachments.'\n    );\n  }\n\n  /**\n   * Convert a tag (@-mention) to message content.\n   *\n   * REQUIRED when tags are used in your application.\n   * Tags allow users to reference entities like \"@customer-123\" or \"@ticket-456\".\n   *\n   * @param tag - The tag content from user message\n   * @returns Message content providing context about the tagged entity\n   * @throws Error if not implemented and tags are present\n   *\n   * @example\n   * ```typescript\n   * async tagToMessageContent(tag: { type: 'input_tag'; text: string }): Promise<ResponseInputContentParam> {\n   *   // Lookup entity by tag\n   *   const customer = await db.customers.findByTag(tag.text);\n   *   return {\n   *     type: 'input_text',\n   *     text: `Customer: ${customer.name} (ID: ${customer.id})`\n   *   };\n   * }\n   * ```\n   */\n  tagToMessageContent(\n    _tag: Extract<UserMessageContent, { type: 'input_tag' }>\n  ): ResponseInputContentParam {\n    throw new Error(\n      'A Tag was included in a UserMessageItem but ' +\n      'InputThreadItemConverter.tagToMessageContent() is not implemented. ' +\n      'Override this method to handle tags.'\n    );\n  }\n\n  /**\n   * Convert a HiddenContextItem to agent input.\n   *\n   * REQUIRED when HiddenContextItems are used.\n   * These are system-level context items not visible to users.\n   *\n   * @param item - The hidden context item\n   * @returns Input items for the agent, or null to skip\n   * @throws Error if not implemented and hidden context items are present\n   */\n  hiddenContextToInput(\n    _item: HiddenContextItem\n  ): ResponseInputItem | ResponseInputItem[] | null {\n    throw new Error(\n      'HiddenContextItem was present but ' +\n      'InputThreadItemConverter.hiddenContextToInput() was not implemented. ' +\n      'Override this method to handle hidden context items.'\n    );\n  }\n\n  /**\n   * Convert a WidgetItem to agent input.\n   *\n   * By default, converts widget to JSON description so AI knows it was displayed.\n   * Override to customize how widgets are described to the AI.\n   *\n   * @param item - The widget item from thread history\n   * @returns Input message describing the widget, or null to skip\n   *\n   * @example Default behavior\n   * ```typescript\n   * // Widget item with id \"wid_123\" becomes:\n   * {\n   *   type: 'message',\n   *   role: 'user',\n   *   content: [{\n   *     type: 'input_text',\n   *     text: 'The following graphical UI widget (id: wid_123) was displayed to the user: {\"type\":\"Card\",\"children\":[...]}'\n   *   }]\n   * }\n   * ```\n   */\n  widgetToInput(item: WidgetItem): ResponseInputItem | null {\n    return {\n      type: 'message',\n      role: 'user',\n      content: [\n        {\n          type: 'input_text',\n          text: `The following graphical UI widget (id: ${item.id}) was displayed to the user: ${JSON.stringify(item.widget)}`,\n        },\n      ],\n    };\n  }\n\n  /**\n   * Convert a WorkflowItem to agent input messages.\n   *\n   * By default, workflows are SKIPPED from AI context (returns empty array).\n   * Workflows are visual progress indicators - the AI doesn't need to see them in history.\n   * The actual tool result contains the important information.\n   *\n   * Note: Workflows remain visible in the UI when loading thread history.\n   * They're only skipped from the AI's conversation context.\n   *\n   * @param item - The workflow item from thread history\n   * @returns Empty array (workflows skipped by default)\n   *\n   * @example To include workflows in AI context, override this method:\n   * ```typescript\n   * workflowToInput(item: WorkflowItem): ResponseInputItem[] {\n   *   if (item.workflow.type === 'reasoning') {\n   *     return []; // Skip AI's own thinking\n   *   }\n   *\n   *   const messages: ResponseInputItem[] = [];\n   *   for (const task of item.workflow.tasks) {\n   *     if (task.type === 'custom' && (task.title || task.content)) {\n   *       const taskText = task.title && task.content\n   *         ? `${task.title}: ${task.content}`\n   *         : task.title || task.content;\n   *       messages.push({\n   *         type: 'message',\n   *         role: 'user',\n   *         content: [{\n   *           type: 'input_text',\n   *           text: `Task performed: ${taskText}`\n   *         }]\n   *       });\n   *     }\n   *   }\n   *   return messages;\n   * }\n   * ```\n   */\n  workflowToInput(_item: WorkflowItem): ResponseInputItem[] {\n    // Skip all workflows by default - they're UI progress indicators\n    // The actual tool result contains the important information\n    return [];\n  }\n\n  /**\n   * Convert a TaskItem to agent input.\n   *\n   * By default, converts custom tasks to a message describing the work performed.\n   *\n   * @param item - The task item from thread history\n   * @returns Input message describing the task, or null to skip\n   */\n  taskToInput(item: TaskItem): ResponseInputItem | null {\n    if (item.task.type !== 'custom' || (!item.task.title && !item.task.content)) {\n      return null;\n    }\n\n    const title = item.task.title || '';\n    const content = item.task.content || '';\n    const taskText = title && content ? `${title}: ${content}` : title || content;\n\n    return {\n      type: 'message',\n      role: 'user',\n      content: [\n        {\n          type: 'input_text',\n          text: `A message was displayed to the user that the following task was performed:\\n<Task>${taskText}</Task>`,\n        },\n      ],\n    };\n  }\n\n  /**\n   * Convert a UserMessageItem to agent input.\n   *\n   * Handles:\n   * - Text content\n   * - Attachments (images, files)\n   * - Tags (@-mentions)\n   * - Quoted text (reply-to context)\n   *\n   * @param item - The user message item\n   * @param isLastMessage - Whether this is the last message in the sequence (affects quoted text handling)\n   * @returns Array of input messages (user text + optional context messages)\n   *\n   * @example\n   * ```typescript\n   * // User message with text and tag becomes:\n   * [\n   *   {\n   *     type: 'message',\n   *     role: 'user',\n   *     content: [\n   *       { type: 'input_text', text: 'Show me details for @customer-123' }\n   *     ]\n   *   },\n   *   {\n   *     type: 'message',\n   *     role: 'user',\n   *     content: [\n   *       {\n   *         type: 'input_text',\n   *         text: '# User-provided context for @-mentions\\n...\\nCustomer: John Doe (ID: 123)'\n   *       }\n   *     ]\n   *   }\n   * ]\n   * ```\n   */\n  async userMessageToInput(\n    item: UserMessageItem,\n    isLastMessage: boolean = true\n  ): Promise<ResponseInputItem[]> {\n    // Build user text exactly as typed, rendering tags as @key\n    const messageTextParts: string[] = [];\n    const rawTags: Array<Extract<UserMessageContent, { type: 'input_tag' }>> = [];\n\n    for (const part of item.content) {\n      if (part.type === 'input_text') {\n        messageTextParts.push(part.text);\n      } else if (part.type === 'input_tag') {\n        messageTextParts.push(`@${part.text}`);\n        rawTags.push(part);\n      }\n    }\n\n    // Build main user message with text and attachments\n    const userTextItem: ResponseInputMessage = {\n      type: 'message',\n      role: 'user',\n      content: [\n        {\n          type: 'input_text',\n          text: messageTextParts.join(''),\n        },\n        // Add attachment content\n        ...(await Promise.all(\n          item.attachments.map((a) => this.attachmentToMessageContent(a))\n        )),\n      ],\n    };\n\n    // Build context items (prepend later): quoted text and @-mention context\n    const contextItems: ResponseInputItem[] = [];\n\n    // Add quoted text context (only for last message)\n    if (item.quoted_text && isLastMessage) {\n      contextItems.push({\n        type: 'message',\n        role: 'user',\n        content: [\n          {\n            type: 'input_text',\n            text: `The user is referring to this in particular:\\n${item.quoted_text}`,\n          },\n        ],\n      });\n    }\n\n    // Add @-mention context\n    if (rawTags.length > 0) {\n      // Dedupe tags (preserve order)\n      const seen = new Set<string>();\n      const uniqueTags: typeof rawTags = [];\n      for (const tag of rawTags) {\n        if (!seen.has(tag.text)) {\n          seen.add(tag.text);\n          uniqueTags.push(tag);\n        }\n      }\n\n      // Resolve tags to content\n      const tagContent: ResponseInputContentParam[] = uniqueTags.map((tag) =>\n        this.tagToMessageContent(tag)\n      );\n\n      if (tagContent.length > 0) {\n        contextItems.push({\n          type: 'message',\n          role: 'user',\n          content: [\n            {\n              type: 'input_text',\n              text:\n                '# User-provided context for @-mentions\\n' +\n                '- When referencing resolved entities, use their canonical names **without** \\'@\\'.\\n' +\n                '- The \\'@\\' form appears only in user text and should not be echoed.',\n            },\n            ...tagContent,\n          ],\n        });\n      }\n    }\n\n    // Return: [user text, ...context items]\n    return [userTextItem, ...contextItems];\n  }\n\n  /**\n   * Convert an AssistantMessageItem to agent input.\n   *\n   * By default, SKIPS assistant messages (returns null) to avoid conflicts with previousResponseId.\n   * The Agents SDK doesn't handle explicit assistant messages well in conversation history.\n   *\n   * Override this method if you need assistant messages in history (not recommended).\n   *\n   * @param item - The assistant message item\n   * @returns null (assistant messages skipped by default)\n   */\n  async assistantMessageToInput(\n    _item: AssistantMessageItem\n  ): Promise<ResponseInputItem | null> {\n    // Skip assistant messages - they conflict with previousResponseId\n    // and the Agents SDK doesn't handle them well anyway\n    return null;\n  }\n\n  /**\n   * Convert a ClientToolCallItem to agent input.\n   *\n   * Converts both the tool call and its result to agent input format.\n   * Skips pending tool calls (not yet completed).\n   *\n   * @param item - The client tool call item\n   * @returns Array of [function_call, function_call_output], or empty array if pending\n   */\n  async clientToolCallToInput(\n    item: ClientToolCallItem\n  ): Promise<ResponseInputItem[]> {\n    if (item.status === 'pending') {\n      // Filter out pending tool calls - they cannot be sent to the model\n      return [];\n    }\n\n    return [\n      {\n        type: 'function_call',\n        call_id: item.call_id,\n        name: item.name,\n        arguments: JSON.stringify(item.arguments),\n      },\n      {\n        type: 'function_call_output',\n        call_id: item.call_id,\n        output: JSON.stringify(item.output),\n      },\n    ];\n  }\n\n  /**\n   * Convert an EndOfTurnItem to agent input.\n   *\n   * These are UI hints for turn boundaries - not sent to the model.\n   *\n   * @param item - The end of turn item\n   * @returns null (always skipped)\n   */\n  async endOfTurnToInput(_item: EndOfTurnItem): Promise<null> {\n    // Only used for UI hints - you shouldn't need to override this\n    return null;\n  }\n\n  /**\n   * Internal: Convert a single thread item to agent input items.\n   * Routes to appropriate conversion method based on item type.\n   */\n  private async threadItemToInputItems(\n    item: ThreadItem,\n    isLastMessage: boolean = true\n  ): Promise<ResponseInputItem[]> {\n    let result: ResponseInputItem | ResponseInputItem[] | null;\n\n    switch (item.type) {\n      case 'user_message':\n        result = await this.userMessageToInput(item, isLastMessage);\n        break;\n      case 'assistant_message':\n        result = await this.assistantMessageToInput(item);\n        break;\n      case 'client_tool_call':\n        result = await this.clientToolCallToInput(item);\n        break;\n      case 'end_of_turn':\n        result = await this.endOfTurnToInput(item);\n        break;\n      case 'widget':\n        result = this.widgetToInput(item);\n        break;\n      case 'workflow':\n        result = this.workflowToInput(item);\n        break;\n      case 'task':\n        result = this.taskToInput(item);\n        break;\n      case 'hidden_context_item':\n        result = this.hiddenContextToInput(item);\n        break;\n      default:\n        // Exhaustive check\n        const _exhaustive: never = item;\n        throw new Error(`Unknown thread item type: ${(_exhaustive as any).type}`);\n    }\n\n    // Normalize to array\n    if (result === null) {\n      return [];\n    }\n    return Array.isArray(result) ? result : [result];\n  }\n\n  /**\n   * Convert full thread history to agent input.\n   *\n   * This is the main method you'll use. Pass in an array of ThreadItems\n   * (typically loaded from your store) and get back agent input ready\n   * to send to the Agent SDK.\n   *\n   * @param items - Array of thread items (usually from store.loadThreadItems())\n   * @returns Array of input items for Agent SDK\n   *\n   * @example\n   * ```typescript\n   * // Load recent thread history\n   * const historyResult = await store.loadThreadItems(\n   *   threadId,\n   *   null,  // after\n   *   50,    // limit\n   *   'asc', // chronological order\n   *   context\n   * );\n   *\n   * // Convert to agent input (includes widgets, workflows, tasks!)\n   * const converter = new InputThreadItemConverter();\n   * const agentInput = await converter.toAgentInput(historyResult.data);\n   *\n   * // Pass to agent\n   * const result = await run(agent, agentInput, {\n   *   stream: true,\n   *   context: agentContext\n   *   // Note: Don't use previousResponseId when using manual history\n   * });\n   * ```\n   */\n  async toAgentInput(items: ThreadItem[]): Promise<ResponseInputItem[]> {\n    // Shallow copy in case caller mutates the list while we're iterating\n    const itemsCopy = [...items];\n    const output: ResponseInputItem[] = [];\n\n    for (let i = 0; i < itemsCopy.length; i++) {\n      const item = itemsCopy[i]!;\n      const isLast = i === itemsCopy.length - 1;\n\n      const converted = await this.threadItemToInputItems(item, isLast);\n      output.push(...converted);\n    }\n\n    return output;\n  }\n}\n\n/**\n * Default converter instance.\n * Use this for simple cases without custom attachment/tag handling.\n */\nexport const defaultInputConverter = new InputThreadItemConverter();\n","import type { UserMessageItem, ThreadItem } from '../types/items.js';\nimport {\n  defaultInputConverter,\n  type ResponseInputItem,\n} from './input-item-converter.js';\n\n/**\n * Converts a ChatKit UserMessageItem to Agent SDK input format (simple version).\n *\n * This is a simple converter that extracts text content from the user message\n * and formats it for the Agent SDK. For more complex conversions (e.g., handling\n * attachments, multiple content types), you can create a custom converter.\n *\n * @param userMessage - The ChatKit user message to convert\n * @returns Agent SDK input format (array of message objects)\n *\n * @example Single message (simple)\n * ```typescript\n * const userMessage: UserMessageItem = {\n *   type: 'user_message',\n *   id: 'msg_123',\n *   thread_id: 'thr_abc',\n *   created_at: '2025-10-09T12:00:00Z',\n *   content: [{\n *     type: 'input_text',\n *     text: 'Hello, how can you help me?'\n *   }],\n *   attachments: [],\n *   inference_options: {}\n * };\n *\n * const agentInput = await simpleToAgentInput(userMessage);\n * // Returns: [{ role: 'user', content: 'Hello, how can you help me?' }]\n * ```\n */\nexport async function simpleToAgentInput(\n  userMessage: UserMessageItem\n): Promise<Array<{ role: 'user'; content: string }>>;\n\n/**\n * Converts a full thread history (array of ThreadItems) to Agent SDK input format.\n *\n * This enables the AI to see the complete conversation history including\n * widgets, workflows, and tasks that were previously displayed.\n *\n * This is the Python SDK parity version - accepts full thread history!\n *\n * @param items - Array of thread items from conversation history\n * @returns Agent SDK input format (array of input items)\n *\n * @example Full history with widgets\n * ```typescript\n * // Load recent thread history from database\n * const historyResult = await store.loadThreadItems(\n *   threadId,\n *   null,  // after\n *   50,    // limit\n *   'asc', // chronological order\n *   context\n * );\n *\n * // Convert ALL items to agent input (includes widgets, workflows, tasks!)\n * const agentInput = await simpleToAgentInput(historyResult.data);\n *\n * // Pass to agent - AI now knows about widgets that were displayed!\n * const result = await run(agent, agentInput, {\n *   stream: true,\n *   context: agentContext\n *   // Note: Don't use previousResponseId when using manual history\n * });\n * ```\n */\nexport async function simpleToAgentInput(\n  items: ThreadItem[]\n): Promise<ResponseInputItem[]>;\n\n/**\n * Implementation of simpleToAgentInput with overloads.\n */\nexport async function simpleToAgentInput(\n  input: UserMessageItem | ThreadItem[]\n): Promise<Array<{ role: 'user'; content: string }> | ResponseInputItem[]> {\n  // Check if input is an array (full history conversion)\n  if (Array.isArray(input)) {\n    // Use InputThreadItemConverter for full history\n    return await defaultInputConverter.toAgentInput(input);\n  }\n\n  // Single UserMessageItem (simple conversion - backward compatible)\n  const userMessage = input;\n  const text = userMessage.content\n    .filter((c) => c.type === 'input_text')\n    .map((c) => c.text)\n    .join(' ');\n\n  return [\n    {\n      role: 'user',\n      content: text,\n    },\n  ];\n}\n","/**\n * Async Generator Stream Merging Utility\n *\n * This module provides a utility to merge two async generators into a single stream,\n * yielding events as they arrive from either source. This enables combining Agent SDK\n * events with custom integration events (like widgets, workflows, etc.).\n */\n\n/**\n * Wrapper to distinguish events from the secondary stream (custom events)\n */\nexport class EventWrapper<T> {\n  constructor(public readonly event: T) {}\n}\n\n/**\n * Merges two async iterators, yielding events as they arrive from either source.\n *\n * Events from the first iterator (typically Agent SDK) are yielded directly.\n * Events from the second iterator (typically custom events) are wrapped in EventWrapper.\n *\n * This implements a similar pattern to Python's `_merge_generators` using Promise.race\n * to handle whichever iterator produces a value first.\n *\n * @template T1 - Type of events from first iterator (Agent SDK events)\n * @template T2 - Type of events from second iterator (custom events)\n * @param a - First async iterator (e.g., Agent SDK stream)\n * @param b - Second async iterator (e.g., custom event queue)\n * @returns Merged async generator yielding T1 | EventWrapper<T2>\n *\n * @example\n * ```typescript\n * const agentStream = agentRunner.streamEvents();\n * const customEventQueue = createEventQueue();\n *\n * for await (const event of mergeAsyncGenerators(agentStream, customEventQueue)) {\n *   if (event instanceof EventWrapper) {\n *     // This is a custom event\n *     yield event.event;\n *   } else {\n *     // This is an Agent SDK event\n *     processAgentEvent(event);\n *   }\n * }\n * ```\n */\nexport async function* mergeAsyncGenerators<T1, T2>(\n  a: AsyncIterator<T1>,\n  b: AsyncIterator<T2>,\n  onFirstComplete?: () => void\n): AsyncGenerator<T1 | EventWrapper<T2>> {\n  // Track which iterators are still active\n  const iterators = new Map<string, AsyncIterator<T1 | T2>>();\n  iterators.set('a', a as AsyncIterator<T1 | T2>);\n  iterators.set('b', b as AsyncIterator<T1 | T2>);\n\n  // Create promises for the next value from each iterator\n  const pending = new Map<string, Promise<IteratorResult<T1 | T2>>>();\n\n  const createPromise = (_iteratorKey: string, iterator: AsyncIterator<T1 | T2>) => {\n    return iterator.next().catch(() => ({ done: true, value: undefined } as IteratorResult<T1 | T2>));\n  };\n\n  // Initialize pending promises for both iterators\n  for (const [key, iterator] of iterators) {\n    pending.set(key, createPromise(key, iterator));\n  }\n\n  while (pending.size > 0) {\n    // Race to see which iterator produces a value first\n    const raceResult = await Promise.race(\n      Array.from(pending.entries()).map(async ([key, promise]) => ({\n        key,\n        result: await promise,\n      }))\n    );\n\n    const { key, result } = raceResult;\n\n    // Remove the completed promise\n    pending.delete(key);\n\n    if (result.done) {\n      // This iterator is exhausted\n      iterators.delete(key);\n\n      // If the first iterator (agent stream) completes, call the callback\n      if (key === 'a' && onFirstComplete) {\n        onFirstComplete();\n      }\n\n      // If both are done, we're finished\n      if (iterators.size === 0) {\n        break;\n      }\n    } else {\n      // Yield the value\n      if (key === 'b') {\n        // Wrap custom events (from second iterator)\n        yield new EventWrapper(result.value as T2);\n      } else {\n        // Pass through Agent SDK events (from first iterator)\n        yield result.value as T1;\n      }\n\n      // Schedule next value from this iterator\n      const iterator = iterators.get(key);\n      if (iterator) {\n        pending.set(key, createPromise(key, iterator));\n      }\n    }\n  }\n}\n","import type {\n  RunStreamEvent,\n  RunItemStreamEvent,\n  RunToolCallItem,\n  RunToolCallOutputItem,\n  RunHandoffCallItem,\n  RunHandoffOutputItem\n} from '@openai/agents';\nimport type { ThreadStreamEvent } from '../types/events.js';\nimport type { AssistantMessageItem, Annotation, WorkflowItem, ClientToolCallItem } from '../types/items.js';\nimport type { AgentContext } from './types.js';\nimport { defaultGenerateItemId } from '../utils/id.js';\nimport { mergeAsyncGenerators, EventWrapper } from './merge-streams.js';\n\n/**\n * Convert Agent SDK annotations to ChatKit annotation format.\n * Handles file citations and URL citations from the Agent SDK.\n */\nfunction convertAnnotations(sdkAnnotations: any[]): Annotation[] {\n  const result: Annotation[] = [];\n\n  for (const annotation of sdkAnnotations) {\n    if (annotation.type === 'file_citation') {\n      const filename = annotation.filename;\n      if (filename) {\n        result.push({\n          type: 'annotation',\n          source: {\n            type: 'file',\n            filename,\n            title: filename,\n          },\n          index: annotation.index ?? null,\n        });\n      }\n    } else if (annotation.type === 'url_citation') {\n      result.push({\n        type: 'annotation',\n        source: {\n          type: 'url',\n          url: annotation.url,\n          title: annotation.title || annotation.url,\n        },\n        index: annotation.end_index ?? null,\n      });\n    }\n  }\n\n  return result;\n}\n\n/**\n * Converts an Agent SDK Runner stream to ChatKit ThreadStreamEvents.\n *\n * This function bridges the Agent SDK and ChatKit by:\n * 1. Listening to Agent Runner stream events\n * 2. Converting message outputs to ChatKit AssistantMessageItems\n * 3. Saving items to the store\n * 4. Emitting ChatKit-compatible events for the frontend\n *\n * @template TContext - The user-defined context type\n * @param context - The AgentContext containing thread, store, and request context\n * @param agentRunner - The Agent SDK Runner stream (from Runner.runStreamed())\n * @param options - Optional configuration\n * @param options.showThinking - Whether to emit reasoning/workflow events (default: true)\n * @returns AsyncGenerator of ChatKit ThreadStreamEvents\n *\n * @example\n * ```typescript\n * const agentContext: AgentContext<MyContext> = {\n *   thread: currentThread,\n *   store: myStore,\n *   requestContext: { userId: 'user123' }\n * };\n *\n * const runnerStream = Runner.runStreamed(myAgent, input, { context: agentContext });\n *\n * // Show thinking (default)\n * for await (const event of streamAgentResponse(agentContext, runnerStream)) {\n *   yield event;\n * }\n *\n * // Hide thinking\n * for await (const event of streamAgentResponse(agentContext, runnerStream, { showThinking: false })) {\n *   yield event;\n * }\n * ```\n */\nexport async function* streamAgentResponse<TContext = unknown>(\n  context: AgentContext<TContext>,\n  agentRunner: AsyncIterable<RunStreamEvent>,\n  options: { showThinking?: boolean } = {}\n): AsyncGenerator<ThreadStreamEvent> {\n  const fallbackShowThinking = options.showThinking ?? true;\n  let currentMessageId: string | null = null;\n\n  // Track current agent for dynamic showThinking lookup\n  let currentAgentName: string = (context as any).currentAgent || 'unknown';\n\n  // Helper to get showThinking for current agent\n  const getShowThinking = (): boolean => {\n    const agentConfigs = (context as any).agentConfigs;\n    if (agentConfigs && Array.isArray(agentConfigs)) {\n      const agentConfig = agentConfigs.find((a: any) => a.name === currentAgentName);\n      if (agentConfig) {\n        return agentConfig.showThinking || false;\n      }\n    }\n    return fallbackShowThinking;\n  };\n\n  // Track text accumulation for each content part separately\n  // Map of content_index -> accumulated text\n  const contentPartTexts = new Map<number, string>();\n\n  // Workflow/reasoning tracking\n  let currentWorkflowId: string | null = null;\n  let currentWorkflowCreatedAt: string | null = null;\n  let currentWorkflowTasks: Array<{ type: 'thought'; content: string; title?: string | null }> = [];\n  let streamingThoughtIndex: number | null = null;\n\n  // Tool call tracking for client-side tool execution\n  let currentToolCall: string | null = null;\n  let currentToolCallItemId: string | null = null;\n\n  // Tool call tracking for database logging (maps callId -> start timestamp)\n  const toolCallTimestamps = new Map<string, number>();\n\n  try {\n    // Merge Agent SDK stream with custom event queue\n    // Convert AsyncIterables to AsyncIterators\n    const agentIterator = agentRunner[Symbol.asyncIterator]();\n    const eventsIterator = context._events[Symbol.asyncIterator]();\n\n    // Complete the events queue when the agent stream finishes\n    const mergedStream = mergeAsyncGenerators(\n      agentIterator,\n      eventsIterator,\n      () => {\n        console.log('[StreamConverter]  Agent stream completed, closing event queue...');\n        context._events.complete();\n      }\n    );\n\n    for await (const event of mergedStream) {\n      // Handle custom events from AgentContext (widgets, workflows, etc.)\n      if (event instanceof EventWrapper) {\n        const customEvent = event.event as ThreadStreamEvent;\n\n        // Close workflow if a visible item is added after it\n        if (\n          customEvent.type === 'thread.item.added' ||\n          customEvent.type === 'thread.item.done'\n        ) {\n          const item = customEvent.item;\n          if (\n            currentWorkflowId &&\n            item.type !== 'client_tool_call' &&\n            item.type !== 'hidden_context_item' &&\n            getShowThinking()\n          ) {\n            // End workflow before emitting custom item (only if it has tasks)\n            if (currentWorkflowTasks.length > 0) {\n              const workflowItem: WorkflowItem = {\n                type: 'workflow',\n                id: currentWorkflowId,\n                thread_id: context.thread.id,\n                created_at: currentWorkflowCreatedAt || new Date().toISOString(),\n                workflow: {\n                  type: 'reasoning',\n                  tasks: currentWorkflowTasks,\n                  expanded: false,\n                  summary: null,\n                },\n              };\n\n              yield {\n                type: 'thread.item.done',\n                item: workflowItem,\n              };\n            }\n\n            // Reset workflow state\n            currentWorkflowId = null;\n            currentWorkflowCreatedAt = null;\n            currentWorkflowTasks = [];\n            streamingThoughtIndex = null;\n          }\n        }\n\n        // Emit the custom event\n        yield customEvent;\n        continue;\n      }\n\n      // Handle Agent SDK events\n      // Type guard: if not EventWrapper, it must be RunStreamEvent\n      const agentEvent = event as RunStreamEvent;\n\n      // Handle tool call events for client-side tool execution\n      if (agentEvent.type === 'run_item_stream_event') {\n        const item = agentEvent.item;\n\n        // Check if this is a tool call item with a function call\n        if (\n          item &&\n          item.type === 'tool_call_item' &&\n          (item as any).raw_item?.type === 'function_call'\n        ) {\n          const rawItem = (item as any).raw_item;\n          currentToolCall = rawItem.call_id || null;\n          currentToolCallItemId = rawItem.id || null;\n        }\n\n        // Log tool calls from SDK stream to database\n        const itemEvent = agentEvent as RunItemStreamEvent;\n\n        // Tool call started\n        if (itemEvent.name === 'tool_called' && itemEvent.item.type === 'tool_call_item') {\n          const toolItem = itemEvent.item as RunToolCallItem;\n          const rawItem = toolItem.rawItem;\n\n          if (rawItem.type === 'function_call') {\n            const callId = rawItem.callId;\n            toolCallTimestamps.set(callId, Date.now());\n\n            const toolCallItem = {\n              id: `tool_${callId}`,\n              type: 'server_tool_call',\n              thread_id: context.thread.id,\n              name: rawItem.name,\n              status: 'running',\n              arguments: JSON.parse(rawItem.arguments || '{}'),\n              created_at: new Date().toISOString()\n            };\n\n            console.log(`[StreamConverter]  Tool called: ${rawItem.name} (${callId})`);\n\n            await context.store.addThreadItem(\n              context.thread.id,\n              toolCallItem as any,\n              context.requestContext\n            );\n          }\n        }\n\n        // Tool call finished\n        else if (itemEvent.name === 'tool_output' && itemEvent.item.type === 'tool_call_output_item') {\n          const outputItem = itemEvent.item as RunToolCallOutputItem;\n          const rawItem = outputItem.rawItem;\n\n          if (rawItem.type === 'function_call_result') {\n            const callId = rawItem.callId;\n            const startTime = toolCallTimestamps.get(callId);\n            const duration = startTime ? Date.now() - startTime : null;\n\n            // Use startTime + duration for accurate completion timestamp\n            // (not current time, which would be after widget creation)\n            const completionTime = startTime && duration\n              ? new Date(startTime + duration).toISOString()\n              : new Date().toISOString();\n\n            const toolResultItem = {\n              id: `tool_${callId}_result`,\n              type: 'server_tool_call',\n              thread_id: context.thread.id,\n              name: rawItem.name,\n              status: rawItem.status === 'completed' ? 'completed' : 'failed',\n              result: outputItem.output,\n              duration_ms: duration,\n              created_at: completionTime\n            };\n\n            console.log(`[StreamConverter]  Tool completed: ${rawItem.name} (${duration}ms)`);\n\n            await context.store.addThreadItem(\n              context.thread.id,\n              toolResultItem as any,\n              context.requestContext\n            );\n\n            toolCallTimestamps.delete(callId);\n          }\n        }\n\n        // Handoff requested\n        else if (itemEvent.name === 'handoff_requested' && itemEvent.item.type === 'handoff_call_item') {\n          const handoffItem = itemEvent.item as RunHandoffCallItem;\n          const rawItem = handoffItem.rawItem;\n\n          if (rawItem.type === 'function_call') {\n            const callId = rawItem.callId;\n            const targetAgent = rawItem.name; // Handoff function name is the target agent\n\n            // Parse arguments to get reason\n            const args = JSON.parse(rawItem.arguments || '{}');\n            const reason = args.reason || `Handoff to ${targetAgent}`;\n\n            const handoffRequestItem = {\n              id: `handoff_${callId}`,\n              type: 'handoff',\n              thread_id: context.thread.id,\n              from: handoffItem.agent.name,\n              to: targetAgent,\n              reason,\n              status: 'requested',\n              created_at: new Date().toISOString()\n            };\n\n            console.log(`[StreamConverter]  Handoff requested: ${handoffItem.agent.name}  ${targetAgent}`);\n\n            await context.store.addThreadItem(\n              context.thread.id,\n              handoffRequestItem as any,\n              context.requestContext\n            );\n          }\n        }\n\n        // Handoff occurred (completed)\n        else if (itemEvent.name === 'handoff_occurred' && itemEvent.item.type === 'handoff_output_item') {\n          const handoffOutputItem = itemEvent.item as RunHandoffOutputItem;\n          const rawItem = handoffOutputItem.rawItem;\n\n          if (rawItem.type === 'function_call_result') {\n            const callId = rawItem.callId;\n\n            // Update current agent tracking\n            currentAgentName = handoffOutputItem.targetAgent.name;\n            console.log(`[StreamConverter]  Agent switched to: ${currentAgentName} (showThinking: ${getShowThinking()})`);\n\n            const handoffCompleteItem = {\n              id: `handoff_${callId}_completed`,\n              type: 'handoff',\n              thread_id: context.thread.id,\n              from: handoffOutputItem.sourceAgent.name,\n              to: handoffOutputItem.targetAgent.name,\n              reason: '', // Reason was already in the request\n              status: rawItem.status === 'completed' ? 'completed' : 'failed',\n              created_at: new Date().toISOString()\n            };\n\n            console.log(`[StreamConverter]  Handoff completed: ${handoffOutputItem.sourceAgent.name}  ${handoffOutputItem.targetAgent.name}`);\n\n            await context.store.addThreadItem(\n              context.thread.id,\n              handoffCompleteItem as any,\n              context.requestContext\n            );\n          }\n        }\n      }\n\n      // Handle Agent SDK raw model stream events\n      if (agentEvent.type === 'raw_model_stream_event') {\n        const { data } = agentEvent;\n\n        // Handle item creation (response.output_item.added)\n        if (data.type === 'model' && data.event?.type === 'response.output_item.added') {\n          const item = data.event.item;\n\n          // Handle reasoning item added - create workflow now so delta handlers can populate it\n          if (item && item.type === 'reasoning') {\n            console.log('[StreamConverter] Reasoning item ADDED - creating workflow for thinking');\n\n            // Create workflow immediately if showThinking is true\n            // Summary will be populated by response.reasoning_summary_text.delta/done events\n            if (getShowThinking()) {\n              // Close any existing workflow before starting new one (only if it has tasks)\n              if (currentWorkflowId && currentWorkflowTasks.length > 0) {\n                const workflowItem: WorkflowItem = {\n                  type: 'workflow',\n                  id: currentWorkflowId,\n                  thread_id: context.thread.id,\n                  created_at: currentWorkflowCreatedAt || new Date().toISOString(),\n                  workflow: {\n                    type: 'reasoning',\n                    tasks: currentWorkflowTasks,\n                    expanded: false,\n                    summary: null,\n                  },\n                };\n\n                yield {\n                  type: 'thread.item.done',\n                  item: workflowItem,\n                };\n              } else if (currentWorkflowId) {\n                // Discard empty workflow silently\n                console.log('[StreamConverter]  Discarding empty workflow before creating new one');\n              }\n\n              // Create new reasoning workflow\n              currentWorkflowId = defaultGenerateItemId('workflow');\n              currentWorkflowCreatedAt = new Date().toISOString();\n              currentWorkflowTasks = [];\n              streamingThoughtIndex = null;\n\n              const workflowItem: WorkflowItem = {\n                type: 'workflow',\n                id: currentWorkflowId,\n                thread_id: context.thread.id,\n                created_at: currentWorkflowCreatedAt,\n                workflow: {\n                  type: 'reasoning',\n                  tasks: [],\n                  expanded: true,\n                  summary: null,\n                },\n              };\n\n              console.log('[StreamConverter]  Creating workflow item with ID:', currentWorkflowId);\n\n              yield {\n                type: 'thread.item.added',\n                item: workflowItem,\n              };\n            }\n          }\n\n          // Handle message creation\n          else if (item && item.type === 'message' && item.role === 'assistant') {\n            // Close workflow if one is active (message comes after reasoning)\n            // Only emit if workflow has tasks (filter out empty ones)\n            if (currentWorkflowId && currentWorkflowTasks.length > 0) {\n              const workflowItem: WorkflowItem = {\n                type: 'workflow',\n                id: currentWorkflowId,\n                thread_id: context.thread.id,\n                created_at: currentWorkflowCreatedAt || new Date().toISOString(),\n                workflow: {\n                  type: 'reasoning',\n                  tasks: currentWorkflowTasks,\n                  expanded: false,\n                  summary: null,\n                },\n              };\n\n              yield {\n                type: 'thread.item.done',\n                item: workflowItem,\n              };\n            }\n\n            // Reset workflow state\n            if (currentWorkflowId) {\n              currentWorkflowId = null;\n              currentWorkflowCreatedAt = null;\n              currentWorkflowTasks = [];\n              streamingThoughtIndex = null;\n            }\n\n            // Reuse the Agent SDK's message ID for consistency\n            currentMessageId = item.id || defaultGenerateItemId('message');\n\n            // Clear content part text tracking for new message\n            contentPartTexts.clear();\n\n            // Guard: currentMessageId should always be set at this point\n            if (!currentMessageId) {\n              continue;\n            }\n\n            // Emit thread.item.added event (ChatKit expects this when item starts)\n            const initialItem: AssistantMessageItem = {\n              type: 'assistant_message',\n              id: currentMessageId,\n              thread_id: context.thread.id,\n              created_at: new Date().toISOString(),\n              content: [],\n            };\n\n            yield {\n              type: 'thread.item.added',\n              item: initialItem,\n            };\n          }\n        }\n\n        // Handle content part added - Initialize content structure\n        else if (data.type === 'model' && data.event?.type === 'response.content_part.added') {\n          const part = data.event.part;\n          if (currentMessageId && part?.type === 'output_text') {\n            // Convert Agent SDK annotations to ChatKit format\n            const annotations = part.annotations ? convertAnnotations(part.annotations) : [];\n\n            // Emit content part added event with initial structure\n            yield {\n              type: 'thread.item.updated',\n              item_id: currentMessageId,\n              update: {\n                type: 'assistant_message.content_part.added',\n                content_index: data.event.content_index,\n                content: {\n                  type: 'output_text',\n                  text: part.text || '',\n                  annotations,\n                },\n              },\n            };\n          }\n        }\n\n        // Handle text delta events\n        else if (data.type === 'output_text_delta') {\n          if (currentMessageId) {\n            const delta = data.delta || '';\n            const contentIndex = (data as any).content_index ?? 0;\n\n            if (delta) {\n              // Accumulate text for this specific content part\n              const currentText = contentPartTexts.get(contentIndex) || '';\n              contentPartTexts.set(contentIndex, currentText + delta);\n\n              // Emit text delta event wrapped in thread.item.updated\n              yield {\n                type: 'thread.item.updated',\n                item_id: currentMessageId,\n                update: {\n                  type: 'assistant_message.content_part.text_delta',\n                  content_index: contentIndex,\n                  delta,\n                },\n              };\n            }\n          }\n        }\n\n        // Handle content part completion (response.output_text.done)\n        else if (data.type === 'model' && data.event?.type === 'response.output_text.done') {\n          if (currentMessageId) {\n            const contentIndex = data.event.content_index ?? 0;\n            const finalText = contentPartTexts.get(contentIndex) || '';\n\n            // Emit content part done event with final text\n            yield {\n              type: 'thread.item.updated',\n              item_id: currentMessageId,\n              update: {\n                type: 'assistant_message.content_part.done',\n                content_index: contentIndex,\n                content: {\n                  type: 'output_text',\n                  text: finalText,\n                  annotations: [],\n                },\n              },\n            };\n          }\n        }\n\n        // Handle reasoning summary delta (streaming thoughts)\n        else if (data.type === 'model' && data.event?.type === 'response.reasoning_summary_text.delta') {\n          if (currentWorkflowId && getShowThinking()) {\n            const delta = data.event.delta || '';\n            const summaryIndex = data.event.summary_index ?? 0;\n\n            // Stream the first thought to show it immediately\n            if (currentWorkflowTasks.length === 0) {\n              streamingThoughtIndex = summaryIndex;\n              const thought = {\n                type: 'thought' as const,\n                content: delta,\n                title: null,\n              };\n              currentWorkflowTasks.push(thought);\n\n              yield {\n                type: 'thread.item.updated',\n                item_id: currentWorkflowId,\n                update: {\n                  type: 'workflow.task.added',\n                  task_index: 0,\n                  task: thought,\n                },\n              };\n            }\n            // Continue streaming the current thought\n            else if (streamingThoughtIndex === summaryIndex && currentWorkflowTasks[0]) {\n              currentWorkflowTasks[0].content += delta;\n\n              yield {\n                type: 'thread.item.updated',\n                item_id: currentWorkflowId,\n                update: {\n                  type: 'workflow.task.updated',\n                  task_index: 0,\n                  task: currentWorkflowTasks[0],\n                },\n              };\n            }\n          }\n        }\n\n        // Handle reasoning summary done (finalize thought)\n        else if (data.type === 'model' && data.event?.type === 'response.reasoning_summary_text.done') {\n          if (currentWorkflowId && getShowThinking()) {\n            const text = data.event.text || '';\n            const summaryIndex = data.event.summary_index ?? 0;\n\n            // Finalize the streaming thought\n            if (streamingThoughtIndex === summaryIndex && currentWorkflowTasks[0]) {\n              currentWorkflowTasks[0].content = text;\n\n              yield {\n                type: 'thread.item.updated',\n                item_id: currentWorkflowId,\n                update: {\n                  type: 'workflow.task.updated',\n                  task_index: 0,\n                  task: currentWorkflowTasks[0],\n                },\n              };\n\n              streamingThoughtIndex = null;\n            }\n            // Add a new thought (wasn't streamed)\n            else {\n              const thought = {\n                type: 'thought' as const,\n                content: text,\n                title: null,\n              };\n              const taskIndex = currentWorkflowTasks.length;\n              currentWorkflowTasks.push(thought);\n\n              yield {\n                type: 'thread.item.updated',\n                item_id: currentWorkflowId,\n                update: {\n                  type: 'workflow.task.added',\n                  task_index: taskIndex,\n                  task: thought,\n                },\n              };\n            }\n          }\n        }\n\n        // Handle message completion (response.output_item.done for type \"message\")\n        else if (data.type === 'model' && data.event?.type === 'response.output_item.done') {\n          const item = data.event.item;\n\n          // Handle reasoning item completion - close workflow if it has content\n          if (item && item.type === 'reasoning') {\n            console.log('[StreamConverter] Reasoning item DONE - closing workflow if it has content');\n\n            // Close workflow only if it has tasks (filter out empty \"thought for a while\")\n            if (currentWorkflowId && currentWorkflowTasks.length > 0) {\n              const workflowItem: WorkflowItem = {\n                type: 'workflow',\n                id: currentWorkflowId,\n                thread_id: context.thread.id,\n                created_at: currentWorkflowCreatedAt || new Date().toISOString(),\n                workflow: {\n                  type: 'reasoning',\n                  tasks: currentWorkflowTasks,\n                  expanded: false,\n                  summary: null,\n                },\n              };\n\n              yield {\n                type: 'thread.item.done',\n                item: workflowItem,\n              };\n\n              currentWorkflowId = null;\n              currentWorkflowCreatedAt = null;\n              currentWorkflowTasks = [];\n              streamingThoughtIndex = null;\n            } else if (currentWorkflowId) {\n              // Workflow exists but has no tasks - discard it silently\n              console.log('[StreamConverter]  Discarding empty reasoning workflow');\n              currentWorkflowId = null;\n              currentWorkflowCreatedAt = null;\n              currentWorkflowTasks = [];\n              streamingThoughtIndex = null;\n            }\n          }\n\n          if (item && item.type === 'message' && item.role === 'assistant' && currentMessageId) {\n            // Extract content parts with annotations from the SDK's complete item\n            const contentParts = item.content?.map((part: any) => {\n              if (part.type === 'output_text') {\n                const annotations = part.annotations ? convertAnnotations(part.annotations) : [];\n                return {\n                  type: 'output_text' as const,\n                  text: part.text || '',\n                  annotations,\n                };\n              }\n              // Handle other content types (refusal, etc.)\n              return {\n                type: 'output_text' as const,\n                text: part.text || '',\n                annotations: [],\n              };\n            }) || [];\n\n            // Create final AssistantMessageItem\n            const finalItem: AssistantMessageItem = {\n              type: 'assistant_message',\n              id: currentMessageId,\n              thread_id: context.thread.id,\n              created_at: new Date().toISOString(),\n              content: contentParts,\n            };\n\n            // Save to store\n            await context.store.addThreadItem(\n              context.thread.id,\n              finalItem,\n              context.requestContext\n            );\n\n            // Emit thread.item.done event\n            yield {\n              type: 'thread.item.done',\n              item: finalItem,\n            };\n\n            // Reset state\n            currentMessageId = null;\n            contentPartTexts.clear();\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // Complete the queue to stop waiting for events\n    context._events.complete();\n\n    // Emit error event\n    yield {\n      type: 'error',\n      code: 'agent_error',\n      message:\n        error instanceof Error\n          ? error.message\n          : 'An error occurred while processing agent response',\n      allow_retry: true,\n    };\n\n    // Re-throw to exit\n    return;\n  }\n\n  // NOTE: No need to call complete() here - it's called by mergeAsyncGenerators callback\n  // when the agent stream finishes, which ensures the events queue drains before the loop exits\n\n  // Emit client tool call if one was set by a tool\n  // This must happen AFTER the try block completes and AFTER completing the queue\n  if (context.clientToolCall) {\n    console.log('[StreamConverter]  Client tool call detected! Emitting event...');\n    const itemId = currentToolCallItemId || context.store.generateItemId(\n      'tool_call',\n      context.thread,\n      context.requestContext\n    );\n\n    const callId = currentToolCall || context.store.generateItemId(\n      'tool_call',\n      context.thread,\n      context.requestContext\n    );\n\n    const clientToolCallItem: ClientToolCallItem = {\n      type: 'client_tool_call',\n      id: itemId,\n      thread_id: context.thread.id,\n      created_at: new Date().toISOString(),\n      status: 'pending',\n      call_id: callId,\n      name: context.clientToolCall.name,\n      arguments: context.clientToolCall.arguments,\n    };\n\n    console.log('[StreamConverter]  Emitting client_tool_call:', JSON.stringify(clientToolCallItem, null, 2));\n\n    // Emit the client tool call item\n    yield {\n      type: 'thread.item.done',\n      item: clientToolCallItem,\n    };\n\n    console.log('[StreamConverter]  Client tool call event emitted successfully');\n  }\n\n  console.log('[StreamConverter]  Stream complete - generator ending');\n}\n","import type { RunItem } from '@openai/agents';\nimport type { ThreadMetadata } from '../types/thread.js';\nimport type { ThreadItem, AssistantMessageItem } from '../types/items.js';\nimport type { Store } from '../store/Store.js';\n\n/**\n * Base class for converting Agent SDK RunItems to ChatKit ThreadItems.\n *\n * This abstract class allows you to customize how Agent outputs are converted\n * to ChatKit items. Extend this class to implement custom conversion logic\n * for your specific use case.\n *\n * @template TContext - The user-defined context type\n *\n * @example\n * ```typescript\n * class CustomItemConverter<TContext> extends ThreadItemConverter<TContext> {\n *   async convert(\n *     agentOutput: RunItem,\n *     thread: ThreadMetadata,\n *     store: Store<TContext>,\n *     context: TContext\n *   ): Promise<ThreadItem> {\n *     // Custom conversion logic here\n *     // For example, handle tool calls, add metadata, etc.\n *     return customThreadItem;\n *   }\n * }\n * ```\n */\nexport abstract class ThreadItemConverter<TContext = unknown> {\n  /**\n   * Converts an Agent SDK RunItem to a ChatKit ThreadItem.\n   *\n   * @param agentOutput - The Agent SDK RunItem to convert\n   * @param thread - The current thread metadata\n   * @param store - The store instance for generating IDs or fetching additional data\n   * @param context - The user-defined request context\n   * @returns The converted ChatKit ThreadItem\n   */\n  abstract convert(\n    agentOutput: RunItem,\n    thread: ThreadMetadata,\n    store: Store<TContext>,\n    context: TContext\n  ): Promise<ThreadItem>;\n}\n\n/**\n * Default implementation of ThreadItemConverter that handles basic text message conversion.\n *\n * This converter extracts text output from Agent message items and creates\n * ChatKit AssistantMessageItems. For more advanced conversions (tool calls,\n * handoffs, etc.), extend the ThreadItemConverter class.\n *\n * @template TContext - The user-defined context type\n */\nexport class DefaultThreadItemConverter<\n  TContext = unknown,\n> extends ThreadItemConverter<TContext> {\n  async convert(\n    agentOutput: RunItem,\n    thread: ThreadMetadata,\n    store: Store<TContext>,\n    context: TContext\n  ): Promise<ThreadItem> {\n    // Import extractAllTextOutput dynamically\n    const agentsSdk = await import('@openai/agents');\n    const text = agentsSdk.extractAllTextOutput([agentOutput]);\n\n    // Generate item ID\n    const itemId = store.generateItemId('message', thread, context);\n\n    // Create AssistantMessageItem\n    const item: AssistantMessageItem = {\n      type: 'assistant_message',\n      id: itemId,\n      thread_id: thread.id,\n      created_at: new Date().toISOString(),\n      content: [\n        {\n          type: 'output_text',\n          text: text || '',\n          annotations: [],\n        },\n      ],\n    };\n\n    return item;\n  }\n}\n"]}